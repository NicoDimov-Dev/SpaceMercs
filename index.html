<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Mercs Inc</title>
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-primary: #090a13;
            --bg-secondary: #181b25;
            --bg-tertiary: #23253a;
            --text-primary: #7afcff;
            --text-secondary: #46b7b9;
            --border-color: #274472;
            --accent-primary: #ff2a6d;
            --accent-hover: #bd1656;
            --accent-disabled: #31223d;
            --status-available: #23ce6b;
            --status-mission: #ffc600;
            --danger-color: #fe4a49;
            --font-family: 'Share Tech Mono', monospace;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: var(--font-family);
            background: #161a24;
            color: var(--text-primary);
            font-size: 15px;
            text-transform: uppercase;
            overflow: hidden;
        }
        
        /* --- CRT Filter Effects --- */
        .crt-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            border: 2px solid var(--border-color);
            padding: 15px;
            overflow: hidden;
            background: radial-gradient(ellipse at 50% 30%, #23253a 80%, #090a13 100%);
            border-radius: 20px; /* Screen curvature */
            display: flex;
            flex-direction: column;
        }
        .crt-container::before { /* Vignette */
            content: "";
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            box-shadow: inset 0 0 120px 30px rgba(0,0,0,0.75);
            pointer-events: none;
            z-index: 999;
        }
        .crt-container::after { /* Scanlines */
            content: "";
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: repeating-linear-gradient(
                0deg,
                rgba(18,255,255,0.06),
                rgba(18,255,255,0.08) 2px,
                transparent 2px,
                transparent 4px
            );
            mix-blend-mode: lighten;
            opacity: 0.37;
            animation: scanlines 0.25s linear infinite;
            pointer-events: none;
            z-index: 1000;
        }
        @keyframes scanlines {
            0% { background-position-y: 0; }
            100% { background-position-y: 8px; }
        }
        .crt-glow {
            text-shadow: 0 0 3px var(--text-primary);
        }
        /* --- End CRT Filter --- */
        
        header {
            text-align: center;
            padding: 5px 0 15px 0;
            border-bottom: 2px solid var(--border-color);
            flex-shrink: 0;
        }
        .header-title h1 { font-size: 36px; font-weight: 400; margin: 0; line-height: 1; color: var(--text-primary); }
        .header-title p { font-size: 18px; color: var(--text-secondary); margin: 0; }
        
        nav {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            padding: 10px 0;
            border-bottom: 2px solid var(--border-color);
            flex-shrink: 0;
        }
        .nav-button {
            background: none; border: none; color: var(--text-secondary);
            font-family: var(--font-family); font-size: 22px; cursor: pointer;
            text-transform: uppercase;
        }
        .nav-button:hover { color: var(--text-primary); }
        .nav-button.active { color: var(--accent-primary); }
        .nav-hint { color: var(--text-secondary); font-size: 18px; }

        .persistent-resource-bar {
            display: flex;
            justify-content: center;
            gap: 20px;
            padding: 10px 30px;
            background-color: var(--bg-secondary);
            border-bottom: 2px solid var(--border-color);
            flex-shrink: 0;
        }
        .resource-item { display: flex; align-items: center; gap: 8px; font-size: 16px; transition: color 0.3s; }
        .resource-item span { color: var(--accent-primary); }
        @keyframes red-glow { 0%, 100% { color: var(--text-primary); } 50% { color: var(--danger-color); } }
        .resource-glow { animation: red-glow 1s ease-in-out; }

        .page-container { padding: 30px; overflow-y: auto; flex-grow: 1; }
        .page-header { margin-bottom: 25px; }
        .page-header h1 { font-size: 28px; font-weight: 400; }
        .page-header p { color: var(--text-secondary); font-size: 16px; }
        .game-section { display: none; }
        .game-section.active { display: block; }
        .card { border: 2px solid var(--border-color); padding: 20px; margin-bottom: 20px; background: var(--bg-secondary); }
        h2 { font-size: 22px; font-weight: 400; border-bottom: 2px solid var(--border-color); padding-bottom: 5px; margin-bottom: 15px; }
        h3 { font-size: 18px; font-weight: 400; color: var(--text-primary); margin-bottom: 10px; }
        .table-container { border: 2px solid var(--border-color); }
        table { width: 100%; border-collapse: collapse; }
        th, td { padding: 15px; text-align: left; border-bottom: 2px solid var(--border-color); }
        th { color: var(--text-secondary); font-size: 16px; }
        tr:last-child td { border-bottom: none; }
        .status-tag { padding: 2px 6px; text-shadow: none; }
        .status-tag.available { background-color: var(--status-available); color: var(--bg-primary); }
        .status-tag.mission { background-color: var(--status-mission); color: var(--bg-primary); }
        .progress-bar { width: 100%; height: 10px; border: 2px solid var(--accent-primary); }
        .progress-bar-fill { height: 100%; background-color: var(--accent-primary); }
        button {
            background: none; color: var(--accent-primary); border: 2px solid var(--accent-primary);
            padding: 8px 15px; font-family: var(--font-family); font-size: 16px;
            cursor: pointer; text-transform: uppercase;
        }
        button:hover { background-color: var(--accent-primary); color: var(--bg-primary); }
        button:disabled { border-color: var(--text-secondary); color: var(--text-secondary); cursor: not-allowed; }
        button:disabled:hover { background: none; }
        .filter-buttons { display: flex; gap: 10px; margin-bottom: 20px; }
        .filter-buttons button { border: 2px solid var(--text-secondary); color: var(--text-secondary); }
        .filter-buttons button.active { border: 2px solid var(--accent-primary); color: var(--accent-primary); }
        .crafting-grid, .inventory-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); gap: 20px; }
        .recipe-card, .item-card { border: 2px solid var(--border-color); }
        .recipe-card img, .item-card img { width: 100%; height: 120px; object-fit: cover; background-color: #111; border-bottom: 2px solid var(--border-color); }
        .recipe-card-body, .item-card-body { padding: 15px; }
        .recipe-card-body h3, .item-card-body h3 { font-size: 20px; }
        .recipe-card-body p, .item-card-body p { font-size: 14px; color: var(--text-secondary); margin-bottom: 15px; }
        .recipe-card-body button { width: 100%; }
        #map-grid { display: grid; grid-template-columns: repeat(10, 1fr); grid-template-rows: repeat(8, 1fr); gap: 2px; width: 100%; height: 500px; border: 2px solid var(--border-color); background-color: #050505; }
        .map-tile { background-color: var(--bg-primary); cursor: pointer; transition: background-color 0.2s; display: flex; align-items: center; justify-content: center; font-size: 24px; color: var(--text-secondary); position: relative; }
        .map-tile:hover { background-color: var(--bg-tertiary); }
        .map-tile.unlocked { color: var(--text-primary); }
        .map-tile .progress-ring { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%) rotate(-90deg); width: 80%; height: 80%; }
        .map-tile .progress-ring__circle { transition: stroke-dashoffset 0.35s; stroke: var(--text-primary); stroke-width: 4; fill: transparent; }
        .modal { display: none; position: fixed; z-index: 2000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.8); }
        .modal-content { background-color: var(--bg-secondary); border: 2px solid var(--border-color); margin: 10% auto; padding: 25px; width: 90%; max-width: 600px; }
        .close-button { color: var(--text-secondary); float: right; font-size: 28px; font-weight: bold; cursor: pointer; }
        .close-button:hover { color: var(--text-primary); }
        #game-over-overlay, #minigame-overlay, #shooter-overlay, #pre-minigame-overlay, #sudoku-overlay, #mission-success-overlay { display: none; position: fixed; z-index: 3000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.95); justify-content: center; align-items: center; text-align: center; }
        #game-over-overlay h1, #minigame-overlay h1, #shooter-overlay h1, #pre-minigame-overlay h1, #sudoku-overlay h1, #mission-success-overlay h1 { font-size: 48px; color: var(--danger-color); }
        #game-over-overlay p, #minigame-overlay p, #shooter-overlay p, #pre-minigame-overlay p, #sudoku-overlay p, #mission-success-overlay p { font-size: 24px; color: var(--text-primary); }
        #pre-minigame-overlay h1, #mission-success-overlay h1 { color: var(--text-primary); }
        #pre-minigame-overlay button, #mission-success-overlay button { margin-top: 20px; }
        #game-over-buttons button { margin: 0 10px; }
        #minigame-canvas, #shooter-canvas { background: #000; border: 2px solid var(--accent-primary); }
        .equipment-slot { display: flex; justify-content: space-between; align-items: center; padding: 10px; border: 2px solid var(--border-color); margin-bottom: 10px; }
        .action-tooltip { position: absolute; transform: translateY(-110%); background-color: var(--danger-color); color: white; padding: 8px 12px; font-size: 16px; font-weight: 400; z-index: 2100; white-space: nowrap; border: 2px solid white; text-shadow: none; }
        footer {
            border-top: 2px solid var(--border-color);
            padding: 5px 15px;
            margin-top: 10px;
            font-size: 14px;
            color: var(--text-secondary);
            text-align: center;
            flex-shrink: 0;
        }
        #sudoku-container { display: flex; gap: 20px; align-items: center; }
        #sudoku-grid { display: grid; grid-template-columns: repeat(9, 35px); grid-template-rows: repeat(9, 35px); border: 2px solid var(--text-primary); }
        .sudoku-cell { width: 35px; height: 35px; border: 1px solid var(--border-color); display: flex; justify-content: center; align-items: center; font-size: 24px; cursor: pointer; }
        .sudoku-cell:nth-child(3n) { border-right: 2px solid var(--text-primary); }
        .sudoku-cell:nth-child(9n) { border-right: none; }
        #sudoku-grid > .sudoku-cell:nth-child(n+19):nth-child(-n+27),
        #sudoku-grid > .sudoku-cell:nth-child(n+46):nth-child(-n+54) { border-bottom: 2px solid var(--text-primary); }
        .sudoku-cell.pre-filled { color: var(--text-secondary); cursor: default; }
        .sudoku-cell.player-filled { color: #fff; }
        .sudoku-cell.selected { background-color: var(--bg-tertiary); }
        #sudoku-controls { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; }
        #sudoku-controls button { width: 50px; height: 50px; font-size: 24px; display: flex; justify-content: center; align-items: center; }
        #sudoku-del-btn { grid-column: span 2; }
    </style>
</head>
<body class="crt-glow">

    <div class="crt"></div>
    <div id="game-over-overlay">
        <div>
            <h1 id="game-over-title">CONNECTION TERMINATED</h1>
            <p id="game-over-subtitle">COMMANDER MIA</p>
            <div id="game-over-buttons" style="margin-top: 20px;"></div>
        </div>
    </div>
    <div id="pre-minigame-overlay">
        <div>
            <h1 id="pre-minigame-title"></h1>
            <p id="pre-minigame-objective"></p>
            <p id="pre-minigame-params"></p>
            <button id="start-minigame-btn">START MISSION</button>
        </div>
    </div>
    <div id="mission-success-overlay">
        <div>
            <h1 id="mission-success-title">MISSION SUCCESSFUL</h1>
            <p>Rewards obtained:</p>
            <div id="mission-success-rewards" style="margin: 10px 0;"></div>
            <button id="mission-success-close-btn">CLOSE</button>
        </div>
    </div>
    <div id="minigame-overlay">
        <div>
            <h1>Mine the Asteroid Fields</h1>
            <canvas id="minigame-canvas" width="480" height="320"></canvas>
        </div>
    </div>
    <div id="shooter-overlay">
        <div>
            <h1>Destroy Enemy Fleet</h1>
            <p id="shooter-subtitle">SCORE <span id="shooter-target-score">0</span> TO SUCCEED</p>
            <canvas id="shooter-canvas" width="400" height="600"></canvas>
        </div>
    </div>
    <div id="sudoku-overlay">
        <div>
            <h1>Decrypt the Data Banks</h1>
            <div id="sudoku-container">
                <div id="sudoku-grid"></div>
                <div id="sudoku-controls"></div>
            </div>
             <p id="sudoku-lives" style="margin-top: 10px;"></p>
             <div id="sudoku-retreat-confirm" style="display: none; margin-top: 10px;">
                <p id="sudoku-retreat-text"></p>
                <button id="confirm-retreat-btn" style="border-color: var(--danger-color); color: var(--danger-color);">Confirm</button>
                <button id="cancel-retreat-btn">Cancel</button>
             </div>
            <button id="sudoku-check-btn" style="margin-top: 10px;" disabled>Check Solution</button>
        </div>
    </div>


    <div class="crt-container">
        <header>
            <div class="header-title">
                <h1>Space Mercs Inc</h1>
                <p>by NicoDimov</p>
            </div>
        </header>

        <nav id="main-nav">
            <span class="nav-hint">[LB]</span>
            <button class="nav-button active" data-tab="base">Dashboard</button>
            <button class="nav-button" data-tab="commander">Commander</button>
            <button class="nav-button" data-tab="mercs">Operatives</button>
            <button class="nav-button" data-tab="inventory">Inventory</button>
            <button class="nav-button" data-tab="map">Starmap</button>
            <button class="nav-button" data-tab="crafting">Fabricator</button>
            <button class="nav-button" data-tab="how-to-play" style="color: white;">Guide</button>
            <span class="nav-hint">[RB]</span>
        </nav>
        
        <div id="persistent-resource-bar" class="persistent-resource-bar"></div>

        <main id="main-content" class="page-container">
            <section id="base-section" class="game-section active"><div class="page-header"><h1>Command Dashboard</h1><p>System overview of your orbital platform.</p></div><h2>Fabrication Queue</h2><div class="table-container" id="production-queue-table"></div><h2 style="margin-top: 30px;">Active Missions</h2><div class="table-container" id="active-missions-table"></div></section>
            <section id="commander-section" class="game-section"></section>
            <section id="mercs-section" class="game-section">
                <div class="page-header">
                    <h1 id="operative-roster-title">Operative Roster</h1>
                    <p>Manage your elite crew.</p>
                </div>
                <div class="card">
                    <h2>Recruit New Operative</h2>
                    <p>Find new talent to join your cause. Each operative brings a unique set of skills.</p>
                    <button id="recruit-merc-btn" style="margin-top: 15px;">Hire Operative (1500 Credits)</button>
                </div>
                <div class="filter-buttons" id="merc-filter-buttons"><button class="active" data-filter="all">All</button><button data-filter="available">Available</button><button data-filter="mission">On Mission</button></div>
                <div class="table-container" id="merc-list-table"></div>
            </section>
            <section id="inventory-section" class="game-section"><div class="page-header"><h1>Inventory</h1><p>All fabricated equipment and consumables are stored here.</p></div><div id="inventory-container" class="inventory-grid"></div></section>
            <section id="map-section" class="game-section"><div class="page-header"><h1>Starmap</h1><p>Chart the void. Click a sector to view details and deploy a team.</p></div><div id="map-grid"></div></section>
            <section id="crafting-section" class="game-section"><div class="page-header"><h1>Fabricator</h1><p>Use materials to fabricate equipment and research new technologies.</p></div><div id="crafting-recipes-container"></div></section>
            <section id="how-to-play-section" class="game-section">
                <div class="page-header"><h1>How To Play</h1><p>A guide to surviving in the void.</p></div>
                <div class="card">
                    <h2>General Concept</h2>
                    <p>You are the Commander of Space Mercs Inc, a private military company operating on the fringes of the galaxy. Your goal is to expand your operation by recruiting operatives, fabricating advanced gear, and completing lucrative contracts found on the Starmap.</p>
                </div>
                <div class="card">
                    <h2>Sections</h2>
                    <p><strong>Dashboard:</strong> Your main overview. Track active fabrication jobs and missions.</p><br>
                    <p><strong>Commander:</strong> That's YOU! View your stats and equip your gear. Remember, if you fall in battle, the operation might be over.</p><br>
                    <p><strong>Operatives:</strong> Manage your hired Mercs and their equipment, and recruit new talent. Your ability to hire more operatives depends on your base upgrades.</p><br>
                    <p><strong>Inventory:</strong> View all the weapons, armor, and tools you have fabricated for you and your Mercs.</p><br>
                    <p><strong>Starmap:</strong> Your gateway to the galaxy. Find and deploy to missions here. Unexplored sectors can be scouted with drones. [Drones sent into deep space are lost forever, but the information they deliver is not]</p><br>
                    <p><strong>Fabricator:</strong> Craft new equipment, consumables, and crucial base upgrades.</p>
                </div>
                 <div class="card">
                    <h2>Missions & Minigames</h2>
                    <p>Missions are your primary source of income and resources. When you send an operative on a mission, their success is determined by their Power level versus the mission's Difficulty.</p>
                    <p>When you, the Commander, deploy on a mission, you must complete a minigame to succeed. The type of minigame depends on the mission:</p><br>
                    <p><strong>Mining:</strong> Mine asteroids by clearing all the data blocks with the hacking ball. Control the paddle with your mouse or the left and right arrow keys.</p><br>
                    <p><strong>Combat:</strong> Destroy the required number of enemy ships. Control your ship with the left and right arrow keys and fire with the spacebar.</p><br>
                    <p><strong>Hacking:</strong> Decrypt the data by solving the 9x9 grid. Use the number pad to fill in empty cells. You have a limited number of attempts to check your solution.</p>
                </div>
            </section>
        </main>
        
         <footer>
            <p>Copyright 2984, NicoDimov Corp. All rights reserved. Any unauthorized duplication, distribution, or lobotomization of our intellectual property is strictly prohibited and punishable by immediate termination of your neural license.</p>
        </footer>
    </div>

    <div id="main-modal" class="modal"><div class="modal-content"><span class="close-button">&times;</span><h2 id="modal-title"></h2><div id="modal-body"></div></div></div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {

        let gameLoopInterval = null;

        const missionTemplates = {
            mining: ["Mine Asteroid Field", "Harvest Crystals", "Extract Ore Deposits"],
            combat: ["Destroy Enemy Fleet", "Intercept Hostile Patrol", "Eliminate Pirate Threat"],
            hacking: ["Decrypt Data Banks", "Hack Enemy Coms", "Breach Corporate Firewall"]
        };

        function getRandomMission(type) {
            const names = missionTemplates[type];
            return names[Math.floor(Math.random() * names.length)];
        }

        function createNewMission(excludeType = null) {
            let types = ['mining', 'combat', 'hacking'];
            if (excludeType) {
                types = types.filter(t => t !== excludeType);
            }
            const type = types[Math.floor(Math.random() * types.length)];
            const difficulty = 10 + Math.floor(Math.random() * 40);
            
            let missionRewards = {};
            if (Math.random() < 0.20) {
                // 20% chance for an energy-only mission
                missionRewards = { energy: (50 + Math.floor(Math.random() * 100)) * 7 };
            } else {
                // 80% chance for a standard mission with 2 random rewards
                const rewardPool = ['materials', 'credits', 'fuel', 'supplies'];
                // Shuffle pool
                for (let i = rewardPool.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [rewardPool[i], rewardPool[j]] = [rewardPool[j], rewardPool[i]];
                }
                const reward1_type = rewardPool[0];
                const reward2_type = rewardPool[1];

                missionRewards[reward1_type] = (50 + Math.floor(Math.random() * 200)) * 7;
                missionRewards[reward2_type] = (50 + Math.floor(Math.random() * 200)) * 7;
            }

            return {
                id: `mission_${Date.now()}_${Math.random()}`,
                name: getRandomMission(type),
                type: type,
                difficulty: difficulty,
                cost: { 
                    fuel: 10 + Math.floor(difficulty / 5),
                    supplies: 15 + Math.floor(difficulty / 5) 
                },
                duration: 60 + difficulty,
                rewards: missionRewards
            };
        }

        const gameState = {
            resources: { supplies: 300, fuel: 150, materials: 600, credits: 1500, energy: 180, scoutDrones: 1 },
            maxEnergy: 300,
            maxScoutDrones: 2,
            inventory: [
                { id: 1, name: 'Med-Syringe', type: 'utility', power: 5, img: 'https://placehold.co/400x240/1e1e1e/e0e0e0?text=Med-Syringe' },
                { id: 2, name: 'Pulse Rifle', type: 'weapon', power: 30, img: 'https://placehold.co/400x240/1e1e1e/e0e0e0?text=Pulse+Rifle' }
            ],
            commander: { id: 0, name: 'Commander', class: 'Strategist', level: 1, isCommander: true, equipment: { weapon: null, armor: null, utility: null } },
            mercenaries: [],
            maxMercs: 1,
            missions: { active: [] },
            crafting: {
                queue: [],
                recipes: [
                    { id: 'supply_pack', name: 'Supply Pack', cost: { materials: 40 }, time: 15, category: 'Consumables', type: 'supplies', isUnlocked: true, img: 'https://placehold.co/400x240/1e1e1e/e0e0e0?text=Supply+Pack' },
                    { id: 'fuel_cell', name: 'Stabilized Fuel Cell', cost: { materials: 50, energy: 25 }, time: 20, category: 'Consumables', type: 'fuel', isUnlocked: true, img: 'https://placehold.co/400x240/1e1e1e/e0e0e0?text=Fuel+Cell' },
                    { id: 'medkit', name: 'Med-Syringe', cost: { materials: 25 }, time: 10, category: 'Consumables', type: 'utility', power: 5, isUnlocked: true, img: 'https://placehold.co/400x240/1e1e1e/e0e0e0?text=Med-Syringe' },
                    { id: 'armor1', name: 'Exo-Armor Plating', cost: { materials: 150 }, time: 60, category: 'Armor', type: 'armor', power: 20, isUnlocked: true, img: 'https://placehold.co/400x240/1e1e1e/e0e0e0?text=Exo-Armor' },
                    { id: 'rifle1', name: 'Pulse Rifle', cost: { materials: 200, energy: 25 }, time: 90, category: 'Weapons', type: 'weapon', power: 30, isUnlocked: true, img: 'https://placehold.co/400x240/1e1e1e/e0e0e0?text=Pulse+Rifle' },
                    { id: 'scout_drone', name: 'Scout Drone', cost: { materials: 20, energy: 100 }, time: 30, category: 'Tools', type: 'drone', isUnlocked: true, img: 'https://placehold.co/400x240/1e1e1e/e0e0e0?text=Scout+Drone' },
                    { id: 'roster_upgrade_1', name: 'Expand Bunks (Tier 1)', cost: { materials: 500, credits: 2000 }, time: 180, category: 'Base Upgrades', type: 'research', unlocks: 'roster_upgrade_2', effect: () => { gameState.maxMercs = 2; gameState.maxEnergy += 200; gameState.maxScoutDrones += 1; }, isUnlocked: true, img: 'https://placehold.co/400x240/1e1e1e/e0e0e0?text=Bunks+1' },
                    { id: 'roster_upgrade_2', name: 'Expand Bunks (Tier 2)', cost: { materials: 1000, credits: 5000 }, time: 300, category: 'Base Upgrades', type: 'research', unlocks: 'roster_upgrade_3', effect: () => { gameState.maxMercs = 3; gameState.maxEnergy += 200; gameState.maxScoutDrones += 1; }, isUnlocked: false, img: 'https://placehold.co/400x240/1e1e1e/e0e0e0?text=Bunks+2' },
                    { id: 'roster_upgrade_3', name: 'Expand Bunks (Tier 3)', cost: { materials: 2500, credits: 10000 }, time: 600, category: 'Base Upgrades', type: 'research', unlocks: null, effect: () => { gameState.maxMercs = 5; gameState.maxEnergy += 200; gameState.maxScoutDrones += 1; }, isUnlocked: false, img: 'https://placehold.co/400x240/1e1e1e/e0e0e0?text=Bunks+3' },
                ]
            },
            map: { 
                locations: { 
                    '2,2': { name: 'Derelict Freighter', mission: createNewMission() }, 
                    '5,4': { name: 'Asteroid Cluster', mission: createNewMission() },
                    '7,7': { name: 'Gas Cloud', mission: createNewMission() }
                },
                exploredEmpty: []
            },
            lastMinigamePlayed: null,
            nextMercId: 1,
            nextItemId: 3,
            mercNames: ["Jax", "Vex", "Kira", "Zane", "Nyx", "Roric"],
            mercClasses: ["Marksman", "Vanguard", "Medic", "Technician", "Ghost"],
        };
        
        const elements = {
            mainContent: document.getElementById('main-content'),
            navButtons: document.querySelectorAll('.nav-button'),
            gameSections: document.querySelectorAll('.game-section'),
            resourceBar: document.getElementById('persistent-resource-bar'),
            productionQueueTable: document.getElementById('production-queue-table'),
            activeMissionsTable: document.getElementById('active-missions-table'),
            commanderSection: document.getElementById('commander-section'),
            mercFilterButtons: document.getElementById('merc-filter-buttons'),
            mercListTable: document.getElementById('merc-list-table'),
            operativeRosterTitle: document.getElementById('operative-roster-title'),
            recruitMercBtn: document.getElementById('recruit-merc-btn'),
            inventoryContainer: document.getElementById('inventory-container'),
            craftingRecipesContainer: document.getElementById('crafting-recipes-container'),
            mapGrid: document.getElementById('map-grid'),
            modal: document.getElementById('main-modal'),
            modalTitle: document.getElementById('modal-title'),
            modalBody: document.getElementById('modal-body'),
            closeButton: document.querySelector('.close-button'),
            gameOverOverlay: document.getElementById('game-over-overlay'),
            gameOverTitle: document.getElementById('game-over-title'),
            gameOverSubtitle: document.getElementById('game-over-subtitle'),
            gameOverButtons: document.getElementById('game-over-buttons'),
            preMinigameOverlay: document.getElementById('pre-minigame-overlay'),
            preMinigameTitle: document.getElementById('pre-minigame-title'),
            preMinigameObjective: document.getElementById('pre-minigame-objective'),
            preMinigameParams: document.getElementById('pre-minigame-params'),
            startMinigameBtn: document.getElementById('start-minigame-btn'),
            missionSuccessOverlay: document.getElementById('mission-success-overlay'),
            missionSuccessTitle: document.getElementById('mission-success-title'),
            missionSuccessRewards: document.getElementById('mission-success-rewards'),
            minigameOverlay: document.getElementById('minigame-overlay'),
            minigameCanvas: document.getElementById('minigame-canvas'),
            shooterOverlay: document.getElementById('shooter-overlay'),
            shooterCanvas: document.getElementById('shooter-canvas'),
            shooterTargetScore: document.getElementById('shooter-target-score'),
            sudokuOverlay: document.getElementById('sudoku-overlay'),
            sudokuGrid: document.getElementById('sudoku-grid'),
            sudokuControls: document.getElementById('sudoku-controls'),
            sudokuLives: document.getElementById('sudoku-lives'),
            sudokuCheckBtn: document.getElementById('sudoku-check-btn'),
            sudokuRetreatConfirm: document.getElementById('sudoku-retreat-confirm'),
            sudokuRetreatText: document.getElementById('sudoku-retreat-text'),
        };

        // --- Minigame States & Logic ---
        let breakoutState = {
            active: false,
            animationFrame: null,
            mission: null,
            ball: { x: 0, y: 0, dx: 2, dy: -2, radius: 7 },
            paddle: { height: 10, width: 75, x: 0 },
            bricks: [],
            stars: [],
            score: 0,
            lives: 3,
            keys: { right: false, left: false }
        };

        let shooterState = {
            active: false,
            animationFrame: null,
            mission: null,
            targetScore: 0,
            player: { width: 30, height: 30, x: 0, y: 0, speed: 4, dx: 0 },
            bullets: [],
            enemies: [],
            enemyBullets: [],
            stars: [],
            framesSincePlayerShot: 0,
            framesSinceSpawn: 0,
            lives: 3,
            score: 0,
            keys: { right: false, left: false, space: false }
        };

        let sudokuState = {
            active: false,
            mission: null,
            board: [],
            solution: [],
            selectedCell: null,
            lives: 3
        };

        const getOperativeById = (id) => [gameState.commander, ...gameState.mercenaries].find(op => op.id === id);
        const getMercPower = (merc) => { let power = merc.level * 10; for (const slot in merc.equipment) { if (merc.equipment[slot]) { power += merc.equipment[slot].power; } } return power; };
        const getSuccessChance = (power, difficulty) => Math.round(Math.min(95, 50 + (power - difficulty) * 1.5));
        const hasEnoughResources = (cost) => Object.entries(cost).every(([r, a]) => gameState.resources[r] >= a);
        
        const addResources = (rewards) => { 
            Object.entries(rewards).forEach(([r, a]) => { 
                if(gameState.resources[r] !== undefined) {
                    if (r === 'energy') {
                        gameState.resources.energy = Math.min(gameState.maxEnergy, gameState.resources.energy + a);
                    } else {
                        gameState.resources[r] += a;
                    }
                } 
            }); 
        };
        
        function handleResourceShortage(cost, element) {
            const missing = Object.entries(cost).filter(([res, amount]) => gameState.resources[res] < amount);
            missing.forEach(([res]) => {
                const resElement = document.getElementById(`resource-${res}`);
                if (resElement) {
                    resElement.classList.add('resource-glow');
                    setTimeout(() => resElement.classList.remove('resource-glow'), 1000);
                }
            });
            const tooltip = document.createElement('div');
            tooltip.className = 'action-tooltip';
            tooltip.textContent = 'Missing: ' + missing.map(([res, amount]) => `${amount - gameState.resources[res]} ${res}`).join(', ');
            document.body.appendChild(tooltip);
            const btnRect = element.getBoundingClientRect();
            tooltip.style.left = `${btnRect.left + window.scrollX}px`;
            tooltip.style.top = `${btnRect.top + window.scrollY}px`;
            setTimeout(() => tooltip.remove(), 2000);
        }

        const spendResources = (cost, element) => { 
            if (hasEnoughResources(cost)) {
                Object.entries(cost).forEach(([r, a]) => gameState.resources[r] -= a);
                return true;
            }
            handleResourceShortage(cost, element);
            return false;
        };

        function renderAll() { renderResources(); renderProductionQueue(); renderCommander(); renderMercs(); renderCrafting(); renderActiveMissions(); renderMap(); renderInventory(); }
        
        function renderResources() { 
            elements.resourceBar.innerHTML = Object.entries(gameState.resources).map(([name, value]) => {
                let displayValue = value.toLocaleString();
                let displayName = name.replace(/([A-Z])/g, ' $1');

                if (name === 'energy') {
                    displayValue = `${value.toLocaleString()}/${gameState.maxEnergy.toLocaleString()}`;
                } else if (name === 'scoutDrones') {
                    displayValue = `${value.toLocaleString()}/${gameState.maxScoutDrones.toLocaleString()}`;
                }

                return `<div class="resource-item" id="resource-${name}">${displayName}: <span>${displayValue}</span></div>`;
            }).join(''); 
        }

        function renderProductionQueue() {
            let content = '<table><tbody><tr><td style="text-align: center; color: var(--text-secondary);">No active fabrication jobs.</td></tr></tbody></table>';
            if (gameState.crafting.queue.length > 0) { content = `<table><thead><tr><th>Item</th><th>Time Left</th><th>Progress</th></tr></thead><tbody>${gameState.crafting.queue.map(item => `<tr><td>${item.name}</td><td>${item.timeLeft}s</td><td><div class="progress-bar"><div class="progress-bar-fill" style="width: ${((item.time - item.timeLeft) / item.time) * 100}%"></div></div></td></tr>`).join('')}</tbody></table>`; }
            elements.productionQueueTable.innerHTML = content;
        }
        function renderCommander() {
            const commander = gameState.commander;
            elements.commanderSection.innerHTML = `<div class="page-header"><h1>Commander Profile</h1></div><div class="card"><h2>${commander.name}</h2><p>Class: ${commander.class} // Level: ${commander.level} // Power: ${getMercPower(commander)}</p></div><div class="card"><h2>Equipment</h2><div id="commander-equipment"></div></div>`;
            renderEquipment(commander, document.getElementById('commander-equipment'));
        }
        function renderMercs(filter = 'all') {
            elements.operativeRosterTitle.innerHTML = `Operative Roster (${gameState.mercenaries.length}/${gameState.maxMercs})`;
            elements.recruitMercBtn.disabled = gameState.mercenaries.length >= gameState.maxMercs;

            const filtered = gameState.mercenaries.filter(merc => {
                const isOnMission = gameState.missions.active.some(m => m.mercId === merc.id);
                if (filter === 'available') return !isOnMission; if (filter === 'mission') return isOnMission; return true;
            });
            let content = '<table><tbody><tr><td style="text-align: center; color: var(--text-secondary);">No operatives match filter.</td></tr></tbody></table>';
            if (filtered.length > 0) {
                content = `<table><thead><tr><th>Name</th><th>Class</th><th>Level</th><th>Power</th><th>Status</th><th></th></tr></thead><tbody>
                    ${filtered.map(merc => `<tr><td>${merc.name}</td><td>${merc.class}</td><td>${merc.level}</td><td>${getMercPower(merc)}</td>
                    <td><span class="status-tag ${gameState.missions.active.some(m=>m.mercId===merc.id) ? 'mission' : 'available'}">${gameState.missions.active.some(m=>m.mercId===merc.id) ? 'On Mission' : 'Available'}</span></td>
                    <td><button class="view-profile-btn" data-merc-id="${merc.id}">View Profile</button></td></tr>`).join('')}</tbody></table>`;
            }
            elements.mercListTable.innerHTML = content;
        }
        function renderCrafting() {
            const categories = [...new Set(gameState.crafting.recipes.map(r => r.category))];
            elements.craftingRecipesContainer.innerHTML = categories.map(cat => `<div><h2>${cat}</h2><div class="crafting-grid">${gameState.crafting.recipes.filter(r => r.category === cat && r.isUnlocked).map(recipe => {
                const queuedItem = gameState.crafting.queue.find(item => item.id === recipe.id);
                const isInQueue = !!queuedItem;
                return `<div class="recipe-card"><img src="${recipe.img}" alt="${recipe.name}"><div class="recipe-card-body"><h3>${recipe.name}</h3><p>${Object.entries(recipe.cost).map(([r,c])=>`${c} ${r}`).join(', ')} // ${recipe.time}s</p><button class="craft-btn" data-recipe-id="${recipe.id}" ${isInQueue ? 'disabled' : ''}>${isInQueue ? `IN QUEUE [${queuedItem.timeLeft}s]` : (recipe.type === 'research' ? 'Research' : 'Fabricate')}</button></div></div>`
            }).join('')}</div></div>`).join('');
        }
        function renderInventory() {
            if (gameState.inventory.length === 0) {
                elements.inventoryContainer.innerHTML = `<p style="color: var(--text-secondary);">Your inventory is empty. Fabricate items to see them here.</p>`;
                return;
            }
            elements.inventoryContainer.innerHTML = gameState.inventory.map(item => `<div class="item-card"><img src="${item.img}" alt="${item.name}"><div class="item-card-body"><h3>${item.name}</h3><p>Type: ${item.type} // Power: ${item.power}</p></div></div>`).join('');
        }
        function renderActiveMissions() {
            let content = '<table><tbody><tr><td style="text-align: center; color: var(--text-secondary);">No missions in progress.</td></tr></tbody></table>';
            if (gameState.missions.active.length > 0) { content = `<table><thead><tr><th>Mission</th><th>Operative</th><th>Time Left</th><th>Progress</th></tr></thead><tbody>${gameState.missions.active.map(mission => `<tr><td>${mission.name}</td><td>${mission.mercId !== null ? getOperativeById(mission.mercId).name : 'Drone'}</td><td>${mission.timeLeft}s</td><td><div class="progress-bar"><div class="progress-bar-fill" style="width: ${((mission.duration - mission.timeLeft) / mission.duration) * 100}%"></div></div></td></tr>`).join('')}</tbody></table>`; }
            elements.activeMissionsTable.innerHTML = content;
        }
        function renderMap() {
            elements.mapGrid.innerHTML = '';
            for (let r = 0; r < 8; r++) { for (let c = 0; c < 10; c++) {
                const coord = `${r},${c}`;
                const tile = document.createElement('div');
                tile.className = 'map-tile';
                tile.dataset.coord = coord;
                const location = gameState.map.locations[coord];
                const activeMission = gameState.missions.active.find(m => m.coord === coord);
                let content = '·';
                if (gameState.map.exploredEmpty.includes(coord)) {
                    content = ' ';
                } else if (location) {
                    tile.classList.add('unlocked');
                    content = '★';
                }
                if (activeMission) {
                    const progress = (activeMission.duration - activeMission.timeLeft) / activeMission.duration;
                    const radius = 18;
                    const circumference = 2 * Math.PI * radius;
                    const offset = circumference - progress * circumference;
                    content += `<svg class="progress-ring" viewBox="0 0 40 40"><circle class="progress-ring__circle" r="${radius}" cx="20" cy="20" style="stroke-dasharray: ${circumference}; stroke-dashoffset: ${offset};"></circle></svg>`;
                }
                tile.innerHTML = content;
                elements.mapGrid.appendChild(tile);
            } }
        }
        function renderEquipment(merc, container) {
            container.innerHTML = Object.keys(merc.equipment).map(slot => `<div class="equipment-slot"><span><strong>${slot.toUpperCase()}:</strong> ${merc.equipment[slot] ? `${merc.equipment[slot].name} (Pwr: ${merc.equipment[slot].power})` : 'Empty'}</span><button class="equip-btn" data-merc-id="${merc.id}" data-slot="${slot}">${merc.equipment[slot] ? 'Change' : 'Equip'}</button></div>`).join('');
        }
        
        function showLocationModal(coord) {
            const location = gameState.map.locations[coord];
            const activeMission = gameState.missions.active.find(m => m.coord === coord);
            elements.modalTitle.textContent = location ? location.name : `Uncharted Sector [${coord}]`;
            let body = '';
            if (activeMission) { body = `<p>A mission is already underway in this sector.</p><p>Time Remaining: ${activeMission.timeLeft}s</p>`; }
            else if (location) {
                const availableMercs = [gameState.commander, ...gameState.mercenaries].filter(m => !gameState.missions.active.some(mis => mis.mercId === m.id));
                let mercSelectorHTML = '<p>No available operatives.</p>';
                if (availableMercs.length > 0) {
                    mercSelectorHTML = `<label for="merc-select" style="display:block; margin-bottom:10px;">Assign Operative:</label><select id="merc-select" style="width: 100%; padding: 8px; margin-bottom: 15px; background: #000; color: #fff; border: 2px solid #fff; font-family: var(--font-family); font-size: 18px;">${availableMercs.map(m => `<option value="${m.id}">${m.name} (Pwr: ${getMercPower(m)})</option>`).join('')}</select><p id="success-chance-p"></p><button id="deploy-btn" data-coord="${coord}">Deploy</button>`;
                }
                body = `<p><strong>Mission:</strong> ${location.mission.name}</p><p><strong>Difficulty:</strong> ${location.mission.difficulty}</p><p><strong>Cost:</strong> ${Object.entries(location.mission.cost).map(([r,v])=>`${v} ${r}`).join(', ')}</p><p><strong>Rewards:</strong> ${Object.entries(location.mission.rewards).map(([r,v])=>`${v} ${r}`).join(', ')}</p><hr style="border-color: var(--border-color); margin: 15px 0;">${mercSelectorHTML}`;
            } else if (gameState.map.exploredEmpty.includes(coord)) {
                body = `<p>SECTOR SCANNED. NOTHING OF INTEREST FOUND.</p>`;
            } else {
                body = `<p>This sector is a mystery.</p>`;
                if (gameState.resources.scoutDrones > 0) { body += `<p>You have ${gameState.resources.scoutDrones} Scout Drone(s) available.</p><button id="scout-btn" data-coord="${coord}">Deploy Scout Drone // 10 Fuel, 10 Supplies, 30s</button>`; }
                else { body += `<p>Fabricate more Scout Drones to explore uncharted space.</p>`; }
            }
            elements.modalBody.innerHTML = body;
            elements.modal.style.display = 'block';

            const mercSelect = document.getElementById('merc-select');
            if (mercSelect) {
                const updateSuccessChance = () => {
                    const location = gameState.map.locations[coord];
                    const selectedMerc = getOperativeById(parseInt(mercSelect.value));
                    if (selectedMerc && location) {
                        if (selectedMerc.isCommander) {
                            document.getElementById('success-chance-p').textContent = 'Success determined by skill.';
                        } else {
                            const chance = getSuccessChance(getMercPower(selectedMerc), location.mission.difficulty);
                            document.getElementById('success-chance-p').textContent = `Success Chance: ${chance}%`;
                        }
                    }
                };
                updateSuccessChance();
                mercSelect.onchange = updateSuccessChance;
            }
        }
        function showMercProfileModal(mercId) {
            const merc = getOperativeById(mercId);
            if (!merc) return;
            elements.modalTitle.textContent = `Profile: ${merc.name}`;
            elements.modalBody.innerHTML = `<div class="card"><h2>${merc.name}</h2><p>Class: ${merc.class} // Level: ${merc.level} // Power: ${getMercPower(merc)}</p></div><div class="card"><h2>Equipment</h2><div id="merc-equipment-container"></div></div>`;
            renderEquipment(merc, document.getElementById('merc-equipment-container'));
            elements.modal.style.display = 'block';
        }
        function showEquipmentModal(mercId, slot) {
            const merc = getOperativeById(mercId);
            const compatibleItems = gameState.inventory.filter(item => item.type === slot);
            elements.modalTitle.textContent = `Equip ${slot.toUpperCase()}`;
            let body = '<p>No compatible items in inventory.</p>';
            if (compatibleItems.length > 0) { body = compatibleItems.map(item => `<div class="equipment-slot"><span>${item.name} (Pwr: ${item.power})</span><button class="equip-item-btn" data-item-id="${item.id}" data-merc-id="${mercId}" data-slot="${slot}">Equip</button></div>`).join(''); }
            body += `<hr style="border-color: var(--border-color); margin: 15px 0;"><button class="unequip-btn" data-merc-id="${mercId}" data-slot="${slot}">Unequip Slot</button>`;
            elements.modalBody.innerHTML = body;
            elements.modal.style.display = 'block';
        }
        function closeModal() { elements.modal.style.display = 'none'; }

        function sendOnMission(mercId, missionTemplate, coord, element) {
            if (mercId === 0) { // Commander's ID is 0
                if (spendResources(missionTemplate.cost, element)) {
                    closeModal();
                    showPreMinigameScreen(missionTemplate.type, missionTemplate);
                }
            } else {
                if (spendResources(missionTemplate.cost, element)) { 
                    gameState.missions.active.push({ ...missionTemplate, mercId, timeLeft: missionTemplate.duration, coord }); 
                    closeModal(); 
                    renderAll(); 
                }
            }
        }
        function scoutSector(coord, element) { if (spendResources({ fuel: 10, supplies: 10 }, element)) { gameState.resources.scoutDrones--; gameState.missions.active.push({ id: 'scout_mission', name: `Scouting ${coord}`, type: 'scout', timeLeft: 30, duration: 30, coord, mercId: null }); closeModal(); renderAll(); } }
        function recruitMerc(element) { if (gameState.mercenaries.length < gameState.maxMercs && spendResources({ credits: 1500 }, element)) { gameState.mercenaries.push({ id: gameState.nextMercId++, name: gameState.mercNames[Math.floor(Math.random() * gameState.mercNames.length)], class: gameState.mercClasses[Math.floor(Math.random() * gameState.mercClasses.length)], level: 1, equipment: { weapon: null, armor: null, utility: null } }); renderAll(); } }
        function craftItem(recipeId, element) {
            const recipe = gameState.crafting.recipes.find(r => r.id === recipeId);
            if (recipe && !gameState.crafting.queue.some(item => item.id === recipeId) && spendResources(recipe.cost, element)) {
                gameState.crafting.queue.push({ ...recipe, timeLeft: recipe.time });
                renderCrafting();
                renderProductionQueue();
            }
        }
        function equipItem(mercId, slot, itemId) {
            const merc = getOperativeById(mercId);
            const itemIndex = gameState.inventory.findIndex(i => i.id === itemId);
            if (!merc || itemIndex === -1) return;
            if (merc.equipment[slot]) { gameState.inventory.push(merc.equipment[slot]); }
            merc.equipment[slot] = gameState.inventory[itemIndex];
            gameState.inventory.splice(itemIndex, 1);
            closeModal();
            renderAll();
        }
        function unequipItem(mercId, slot) {
            const merc = getOperativeById(mercId);
            if (!merc || !merc.equipment[slot]) return;
            gameState.inventory.push(merc.equipment[slot]);
            merc.equipment[slot] = null;
            closeModal();
            renderAll();
        }
        
        function showPreMinigameScreen(type, mission) {
            elements.preMinigameOverlay.style.display = 'flex';
            elements.preMinigameTitle.textContent = `Mission: ${mission.name}`;
            let objective = '';
            let params = '';
            const armorPower = gameState.commander.equipment.armor ? gameState.commander.equipment.armor.power : 0;
            const lives = 2 + Math.floor(armorPower / 20);

            if (type === 'mining') {
                objective = 'Objective: Mine the asteroid fields.';
                const brickCount = (3 + Math.floor(mission.difficulty / 20)) * 5;
                params = `Data Blocks: ${brickCount} // Lives: 3`;
                elements.startMinigameBtn.onclick = () => {
                    elements.preMinigameOverlay.style.display = 'none';
                    startMinigame(mission);
                };
            } else if (type === 'combat') {
                objective = 'Objective: Destroy enemy ships to obtain salvage.';
                const targetScore = 500 + mission.difficulty * 25;
                params = `Target Score: ${targetScore} // Lives: ${lives}`;
                elements.startMinigameBtn.onclick = () => {
                    elements.preMinigameOverlay.style.display = 'none';
                    startShooterMinigame(mission);
                };
            } else { // hacking
                objective = 'Objective: Decrypt the data banks to get the intel.';
                params = `Attempts Remaining: ${lives}`;
                elements.startMinigameBtn.onclick = () => {
                    elements.preMinigameOverlay.style.display = 'none';
                    startSudokuMinigame(mission);
                };
            }
            elements.preMinigameObjective.textContent = objective;
            elements.preMinigameParams.textContent = params;
        }

        function showMissionSuccessModal(mission, minigameType) {
            elements.missionSuccessOverlay.style.display = 'flex';
            let title = 'MISSION SUCCESSFUL';
            if(minigameType === 'mining') title = 'MINING SUCCESSFUL';
            if(minigameType === 'combat') title = 'COMBAT SUCCESSFUL';
            if(minigameType === 'hacking') title = 'HACKING SUCCESSFUL';
            elements.missionSuccessTitle.textContent = title;
            elements.missionSuccessRewards.innerHTML = Object.entries(mission.rewards).map(([res, val]) => `<p>${val} ${res}</p>`).join('');
        }

        function handleCommanderFailure() {
            elements.gameOverOverlay.style.display = 'flex';
            elements.gameOverTitle.textContent = "CONNECTION UNSTABLE";
            elements.gameOverSubtitle.textContent = "Commander link compromised.";
            
            const canContinue = gameState.resources.energy >= 100;
            elements.gameOverButtons.innerHTML = `
                <button id="continue-btn" ${canContinue ? '' : 'disabled'}>Re-establish Link (100 Energy)</button>
                <button id="restart-btn">${canContinue ? 'Abort' : 'Restart'}</button>
            `;
        }

        function gameOver() { 
            clearInterval(gameLoopInterval); 
            elements.gameOverTitle.textContent = "CONNECTION TERMINATED";
            elements.gameOverSubtitle.textContent = "COMMANDER MIA";
            elements.gameOverButtons.innerHTML = `<button id="restart-btn">RESTART</button>`;
            elements.gameOverOverlay.style.display = 'flex';
        }

        function startMinigame(mission) {
            breakoutState.active = true;
            breakoutState.mission = mission;
            elements.minigameOverlay.style.display = 'flex';
            
            const canvas = elements.minigameCanvas;
            breakoutState.ball.x = canvas.width / 2;
            breakoutState.ball.y = canvas.height - 30;
            breakoutState.paddle.x = (canvas.width - breakoutState.paddle.width) / 2;
            breakoutState.lives = 3;
            breakoutState.score = 0;

            breakoutState.stars = [];
            for (let i = 0; i < 50; i++) {
                breakoutState.stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    radius: Math.random() * 1,
                    speed: Math.random() * 0.5 + 0.1
                });
            }

            const brickRowCount = 3 + Math.floor(mission.difficulty / 20);
            const brickColumnCount = 5;
            breakoutState.bricks = [];
            for (let c = 0; c < brickColumnCount; c++) {
                breakoutState.bricks[c] = [];
                for (let r = 0; r < brickRowCount; r++) {
                    breakoutState.bricks[c][r] = { x: 0, y: 0, status: 1 };
                }
            }

            if(breakoutState.animationFrame) cancelAnimationFrame(breakoutState.animationFrame);
            breakoutLoop();
        }

        function endMinigame(isWin) {
            breakoutState.active = false;
            cancelAnimationFrame(breakoutState.animationFrame);
            elements.minigameOverlay.style.display = 'none';

            if (isWin) {
                addResources(breakoutState.mission.rewards);
                gameState.commander.level++;
                const locationKey = Object.keys(gameState.map.locations).find(key => gameState.map.locations[key].mission.id === breakoutState.mission.id);
                if (locationKey) {
                    gameState.map.locations[locationKey].mission = createNewMission('mining');
                }
                showMissionSuccessModal(breakoutState.mission, 'mining');
                renderAll();
            } else {
                handleCommanderFailure();
            }
            breakoutState.mission = null;
        }

        function breakoutLoop() {
            if (!breakoutState.active) return;
            const canvas = elements.minigameCanvas;
            const ctx = canvas.getContext('2d');
            const { ball, paddle, bricks, keys, stars } = breakoutState;

            if (keys.right) paddle.x += 7;
            if (keys.left) paddle.x -= 7;
            if (paddle.x < 0) paddle.x = 0;
            if (paddle.x + paddle.width > canvas.width) paddle.x = canvas.width - paddle.width;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw & Update Stars
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--text-secondary');
            for (const star of stars) {
                star.y += star.speed;
                if (star.y > canvas.height) {
                    star.y = 0;
                    star.x = Math.random() * canvas.width;
                }
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
                ctx.fill();
            }


            let bricksLeft = 0;
            for (let c = 0; c < bricks.length; c++) {
                for (let r = 0; r < bricks[c].length; r++) {
                    if (bricks[c][r].status === 1) {
                        bricksLeft++;
                        let brickX = (c * (75 + 10)) + 30;
                        let brickY = (r * (20 + 10)) + 30;
                        bricks[c][r].x = brickX;
                        bricks[c][r].y = brickY;
                        ctx.beginPath();
                        ctx.rect(brickX, brickY, 75, 20);
                        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent-primary');
                        ctx.fill();
                        ctx.closePath();
                    }
                }
            }

            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--text-primary');
            ctx.fill();
            ctx.closePath();

            ctx.beginPath();
            ctx.rect(paddle.x, canvas.height - paddle.height, paddle.width, paddle.height);
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent-primary');
            ctx.fill();
            ctx.closePath();

            ctx.font = "16px 'Share Tech Mono'";
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--text-primary');
            ctx.fillText("SCORE: " + breakoutState.score, 8, 20);
            ctx.fillText("LIVES: " + breakoutState.lives, canvas.width - 85, 20);

            for (let c = 0; c < bricks.length; c++) {
                for (let r = 0; r < bricks[c].length; r++) {
                    let b = bricks[c][r];
                    if (b.status === 1) {
                        if (ball.x > b.x && ball.x < b.x + 75 && ball.y > b.y && ball.y < b.y + 20) {
                            ball.dy = -ball.dy;
                            b.status = 0;
                            breakoutState.score++;
                            if (breakoutState.score === bricks.length * bricks[0].length) {
                                endMinigame(true);
                                return;
                            }
                        }
                    }
                }
            }
            
            if (ball.x + ball.dx > canvas.width - ball.radius || ball.x + ball.dx < ball.radius) {
                ball.dx = -ball.dx;
            }
            if (ball.y + ball.dy < ball.radius) {
                ball.dy = -ball.dy;
            } else if (ball.y + ball.dy > canvas.height - ball.radius) {
                if (ball.x > paddle.x && ball.x < paddle.x + paddle.width) {
                    ball.dy = -ball.dy;
                } else {
                    breakoutState.lives--;
                    if (!breakoutState.lives) {
                        endMinigame(false);
                        return;
                    } else {
                        ball.x = canvas.width / 2;
                        ball.y = canvas.height - 30;
                        ball.dx = 2;
                        ball.dy = -2;
                        paddle.x = (canvas.width - paddle.width) / 2;
                    }
                }
            }

            ball.x += ball.dx;
            ball.y += ball.dy;

            breakoutState.animationFrame = requestAnimationFrame(breakoutLoop);
        }

        function startShooterMinigame(mission) {
            shooterState.active = true;
            shooterState.mission = mission;
            elements.shooterOverlay.style.display = 'flex';
            
            const canvas = elements.shooterCanvas;
            shooterState.player.x = canvas.width / 2 - shooterState.player.width / 2;
            shooterState.player.y = canvas.height - 60;
            shooterState.score = 0;
            shooterState.targetScore = 500 + mission.difficulty * 25;
            elements.shooterTargetScore.textContent = shooterState.targetScore;
            
            let armorPower = gameState.commander.equipment.armor ? gameState.commander.equipment.armor.power : 0;
            shooterState.lives = 2 + Math.floor(armorPower / 20);

            shooterState.enemies = [];
            shooterState.bullets = [];
            shooterState.enemyBullets = [];
            shooterState.framesSinceSpawn = 0;
            
            shooterState.stars = [];
            for (let i = 0; i < 100; i++) {
                shooterState.stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    radius: Math.random() * 1.5,
                    speed: Math.random() * 3 + 1
                });
            }

            if(shooterState.animationFrame) cancelAnimationFrame(shooterState.animationFrame);
            shooterLoop();
        }

        function endShooterMinigame(isWin) {
            shooterState.active = false;
            cancelAnimationFrame(shooterState.animationFrame);
            elements.shooterOverlay.style.display = 'none';

            if (isWin) {
                addResources(shooterState.mission.rewards);
                gameState.commander.level++;
                const locationKey = Object.keys(gameState.map.locations).find(key => gameState.map.locations[key].mission.id === shooterState.mission.id);
                if (locationKey) {
                    gameState.map.locations[locationKey].mission = createNewMission('combat');
                }
                showMissionSuccessModal(shooterState.mission, 'combat');
                renderAll();
            } else {
                handleCommanderFailure();
            }
            shooterState.mission = null;
        }

        function shooterLoop() {
            if (!shooterState.active) return;
            
            updateShooter();
            drawShooter();

            shooterState.animationFrame = requestAnimationFrame(shooterLoop);
        }

        function updateShooter() {
            const { player, enemies, bullets, enemyBullets, keys, stars } = shooterState;
            const canvas = elements.shooterCanvas;

            // Update Stars
            for(const star of stars) {
                star.y += star.speed;
                if (star.y > canvas.height) {
                    star.y = 0;
                    star.x = Math.random() * canvas.width;
                }
            }

            // Player Movement
            player.dx = 0;
            if (keys.right) player.dx = player.speed;
            if (keys.left) player.dx = -player.speed;
            player.x += player.dx;
            if (player.x < 0) player.x = 0;
            if (player.x + player.width > canvas.width) player.x = canvas.width - player.width;

            // Player Firing
            shooterState.framesSincePlayerShot++;
            if (keys.space && shooterState.framesSincePlayerShot >= 15) {
                bullets.push({ x: player.x + player.width / 2 - 2.5, y: player.y, width: 5, height: 10 });
                shooterState.framesSincePlayerShot = 0;
            }

            // Update Bullets
            for (let i = bullets.length - 1; i >= 0; i--) {
                bullets[i].y -= 7;
                if (bullets[i].y < 0) bullets.splice(i, 1);
            }

            // Enemy Spawning
            shooterState.framesSinceSpawn++;
            if (shooterState.framesSinceSpawn >= 100) {
                const startX = Math.random() * (canvas.width - 40);
                enemies.push({ x: startX, y: -40, width: 40, height: 30, initialX: startX, fireCooldown: Math.random() * 120 + 60, framesSinceFired: 0 });
                shooterState.framesSinceSpawn = 0;
            }

            // Update Enemies
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                enemy.y += 1.5;
                enemy.x = enemy.initialX + Math.sin(enemy.y / 50) * 40;
                enemy.framesSinceFired++;
                if(enemy.framesSinceFired >= enemy.fireCooldown) {
                    enemyBullets.push({ x: enemy.x + enemy.width / 2 - 2.5, y: enemy.y + enemy.height, width: 5, height: 10 });
                    enemy.framesSinceFired = 0;
                }
                if (enemy.y > canvas.height) enemies.splice(i, 1);
            }

            // Update Enemy Bullets
            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                enemyBullets[i].y += 2.5;
                if (enemyBullets[i].y > canvas.height) enemyBullets.splice(i, 1);
            }

            // Collision: Player Bullets vs Enemies
            for (let i = bullets.length - 1; i >= 0; i--) {
                for (let j = enemies.length - 1; j >= 0; j--) {
                    if (!bullets[i]) continue;
                    if (bullets[i].x < enemies[j].x + enemies[j].width && bullets[i].x + bullets[i].width > enemies[j].x && bullets[i].y < enemies[j].y + enemies[j].height && bullets[i].y + bullets[i].height > enemies[j].y) {
                        bullets.splice(i, 1);
                        enemies.splice(j, 1);
                        shooterState.score += 100;
                        if (shooterState.score >= shooterState.targetScore) {
                            endShooterMinigame(true);
                            return;
                        }
                        break;
                    }
                }
            }
            
            // Collision: Player vs Enemies or Enemy Bullets
            const checkPlayerCollision = (thing) => player.x < thing.x + thing.width && player.x + player.width > thing.x && player.y < thing.y + thing.height && player.y + player.height > thing.y;
            
            for (const enemy of enemies) {
                if (checkPlayerCollision(enemy)) {
                    shooterState.lives--;
                    enemies.splice(enemies.indexOf(enemy), 1);
                    if (shooterState.lives <= 0) { endShooterMinigame(false); return; }
                }
            }
            for (const bullet of enemyBullets) {
                if (checkPlayerCollision(bullet)) {
                    shooterState.lives--;
                    enemyBullets.splice(enemyBullets.indexOf(bullet), 1);
                    if (shooterState.lives <= 0) { endShooterMinigame(false); return; }
                }
            }
        }

        function drawShooter() {
            const canvas = elements.shooterCanvas;
            const ctx = canvas.getContext('2d');
            const { player, enemies, bullets, enemyBullets, stars } = shooterState;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw Stars
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--text-secondary');
            for (const star of stars) {
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
                ctx.fill();
            }

            // Player
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--text-primary');
            ctx.beginPath();
            ctx.moveTo(player.x + player.width / 2, player.y);
            ctx.lineTo(player.x, player.y + player.height);
            ctx.lineTo(player.x + player.width, player.y + player.height);
            ctx.closePath();
            ctx.fill();

            // Bullets
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent-primary');
            for(const bullet of bullets) ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);

            // Enemies
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--danger-color');
            for(const enemy of enemies) {
                ctx.beginPath();
                ctx.moveTo(enemy.x, enemy.y);
                ctx.lineTo(enemy.x + enemy.width, enemy.y);
                ctx.lineTo(enemy.x + enemy.width / 2, enemy.y + enemy.height);
                ctx.closePath();
                ctx.fill();
            }

            // Enemy Bullets
            ctx.fillStyle = '#ffc600';
            ctx.shadowColor = '#ff0000';
            ctx.shadowBlur = 10;
            for(const bullet of enemyBullets) ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
            ctx.shadowBlur = 0;

            // UI
            ctx.font = "16px 'Share Tech Mono'";
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--text-primary');
            ctx.fillText("SCORE: " + shooterState.score, 8, 20);
            ctx.fillText("LIVES: " + shooterState.lives, canvas.width - 85, 20);
        }

        function startSudokuMinigame(mission) {
            sudokuState.active = true;
            sudokuState.mission = mission;
            elements.sudokuOverlay.style.display = 'flex';

            const armorPower = gameState.commander.equipment.armor ? gameState.commander.equipment.armor.power : 0;
            sudokuState.lives = 2 + Math.floor(armorPower / 20);
            
            const puzzle = {
                solution: [
                    [5,3,4,6,7,8,9,1,2],
                    [6,7,2,1,9,5,3,4,8],
                    [1,9,8,3,4,2,5,6,7],
                    [8,5,9,7,6,1,4,2,3],
                    [4,2,6,8,5,3,7,9,1],
                    [7,1,3,9,2,4,8,5,6],
                    [9,6,1,5,3,7,2,8,4],
                    [2,8,7,4,1,9,6,3,5],
                    [3,4,5,2,8,6,1,7,9]
                ]
            };
            sudokuState.board = puzzle.solution.map(row => row.map(cell => 0));
            sudokuState.solution = puzzle.solution;

            let clues = 62 - Math.floor(mission.difficulty * 0.5);
            let cells = [];
            for(let r=0; r<9; r++) for(let c=0; c<9; c++) cells.push({r,c});
            
            while(clues > 0 && cells.length > 0) {
                const randIndex = Math.floor(Math.random() * cells.length);
                const {r, c} = cells[randIndex];
                sudokuState.board[r][c] = sudokuState.solution[r][c];
                cells.splice(randIndex, 1);
                clues--;
            }

            renderSudoku();
        }

        function renderSudoku() {
            elements.sudokuGrid.innerHTML = '';
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'sudoku-cell';
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    const val = sudokuState.board[r][c];
                    if (val !== 0) {
                        cell.textContent = Math.abs(val);
                        if (val > 0) { 
                             cell.classList.add('pre-filled');
                        } else { 
                            cell.classList.add('player-filled');
                        }
                    }
                    if (sudokuState.selectedCell && sudokuState.selectedCell.row === r && sudokuState.selectedCell.col === c) {
                        cell.classList.add('selected');
                    }
                    elements.sudokuGrid.appendChild(cell);
                }
            }
            elements.sudokuControls.innerHTML = '';
            for (let i = 1; i <= 9; i++) {
                const btn = document.createElement('button');
                btn.textContent = i;
                btn.className = 'sudoku-control-btn';
                btn.dataset.num = i;
                elements.sudokuControls.appendChild(btn);
            }
            const delBtn = document.createElement('button');
            delBtn.textContent = 'DEL';
            delBtn.id = 'sudoku-del-btn';
            delBtn.className = 'sudoku-control-btn';
            delBtn.dataset.num = 0;
            elements.sudokuControls.appendChild(delBtn);

            const retreatBtn = document.createElement('button');
            retreatBtn.textContent = 'X';
            retreatBtn.id = 'sudoku-retreat-btn';
            retreatBtn.style.borderColor = 'var(--danger-color)';
            retreatBtn.style.color = 'var(--danger-color)';
            elements.sudokuControls.appendChild(retreatBtn);


            elements.sudokuLives.textContent = `Attempts Remaining: ${sudokuState.lives}`;
            const isFull = sudokuState.board.every(row => row.every(cell => cell !== 0));
            elements.sudokuCheckBtn.disabled = !isFull;
        }

        function endSudokuMinigame(isWin) {
            sudokuState.active = false;
            elements.sudokuOverlay.style.display = 'none';

            if (isWin) {
                addResources(sudokuState.mission.rewards);
                gameState.commander.level++;
                const locationKey = Object.keys(gameState.map.locations).find(key => gameState.map.locations[key].mission.id === sudokuState.mission.id);
                if (locationKey) {
                    gameState.map.locations[locationKey].mission = createNewMission('hacking');
                }
                showMissionSuccessModal(sudokuState.mission, 'hacking');
                renderAll();
            } else {
                handleCommanderFailure();
            }
            sudokuState.mission = null;
        }


        document.addEventListener('mousemove', (e) => {
            if (!breakoutState.active) return;
            const canvas = elements.minigameCanvas;
            const relativeX = e.clientX - canvas.getBoundingClientRect().left;
            if (relativeX > 0 && relativeX < canvas.width) {
                breakoutState.paddle.x = relativeX - breakoutState.paddle.width / 2;
            }
        });

        document.addEventListener('keydown', (e) => {
            if (breakoutState.active) {
                if (e.key === 'ArrowRight' || e.key === 'd') breakoutState.keys.right = true;
                if (e.key === 'ArrowLeft' || e.key === 'a') breakoutState.keys.left = true;
            }
            if (shooterState.active) {
                if (e.key === 'ArrowRight' || e.key === 'd') shooterState.keys.right = true;
                if (e.key === 'ArrowLeft' || e.key === 'a') shooterState.keys.left = true;
                if (e.key === ' ') shooterState.keys.space = true;
            }
        });
        document.addEventListener('keyup', (e) => {
            if (breakoutState.active) {
                if (e.key === 'ArrowRight' || e.key === 'd') breakoutState.keys.right = false;
                if (e.key === 'ArrowLeft' || e.key === 'a') breakoutState.keys.left = false;
            }
            if (shooterState.active) {
                if (e.key === 'ArrowRight' || e.key === 'd') shooterState.keys.right = false;
                if (e.key === 'ArrowLeft' || e.key === 'a') shooterState.keys.left = false;
                if (e.key === ' ') shooterState.keys.space = false;
            }
        });

        function gameTick() {
            let needsRender = false;
            // Crafting & Research
            gameState.crafting.queue.forEach(item => item.timeLeft--);
            const finishedJobs = gameState.crafting.queue.filter(item => item.timeLeft <= 0);
            if (finishedJobs.length > 0) {
                finishedJobs.forEach(job => {
                    if (job.type === 'research') { 
                        const recipeToUnlock = gameState.crafting.recipes.find(r => r.id === job.unlocks); 
                        if(recipeToUnlock) recipeToUnlock.isUnlocked = true;
                        if(job.effect) job.effect();
                    }
                    else if (job.type === 'fuel') { gameState.resources.fuel += 50; }
                    else if (job.type === 'supplies') { gameState.resources.supplies += 40; }
                    else if (job.type === 'drone') { gameState.resources.scoutDrones = Math.min(gameState.maxScoutDrones, gameState.resources.scoutDrones + 1); }
                    else { gameState.inventory.push({ ...job, id: gameState.nextItemId++ }); }
                });
                gameState.crafting.queue = gameState.crafting.queue.filter(item => item.timeLeft > 0);
                needsRender = true;
            }
            // Missions
            gameState.missions.active.forEach(mission => mission.timeLeft--);
            const finishedMissions = gameState.missions.active.filter(m => m.timeLeft <= 0);
            if (finishedMissions.length > 0) {
                finishedMissions.forEach(mission => {
                    if (mission.type === 'scout') { if (Math.random() > 0.5) { gameState.map.locations[mission.coord] = { name: 'New Anomaly', mission: createNewMission() }; } else { gameState.map.exploredEmpty.push(mission.coord); } }
                    else {
                        const merc = getOperativeById(mission.mercId);
                        if (Math.random() * 100 < getSuccessChance(getMercPower(merc), mission.difficulty)) { 
                            addResources(mission.rewards); 
                            merc.level++;
                            const locationKey = Object.keys(gameState.map.locations).find(key => gameState.map.locations[key].mission.id === mission.id);
                            if(locationKey) gameState.map.locations[locationKey].mission = createNewMission(mission.type);
                        }
                        else { if (merc.isCommander) { handleCommanderFailure(); return; } }
                    }
                });
                gameState.missions.active = gameState.missions.active.filter(m => m.timeLeft > 0);
                needsRender = true;
            }
            if (needsRender) { renderAll(); } else { renderProductionQueue(); renderActiveMissions(); renderMap(); renderCrafting(); renderResources(); }
        }

        function init() {
            document.addEventListener('click', (e) => {
                const target = e.target;
                const mapTile = target.closest('.map-tile');

                if (mapTile) {
                    showLocationModal(mapTile.dataset.coord);
                } else if (target.matches('.view-profile-btn')) {
                    showMercProfileModal(parseInt(target.dataset.mercId));
                } else if (target.matches('.craft-btn')) {
                    craftItem(target.dataset.recipeId, target);
                } else if (target.matches('.equip-btn')) {
                    showEquipmentModal(parseInt(target.dataset.mercId), target.dataset.slot);
                } else if (target.matches('#recruit-merc-btn')) {
                    recruitMerc(target);
                } else if (target.matches('.equip-item-btn')) {
                    equipItem(parseInt(target.dataset.mercId), target.dataset.slot, parseInt(target.dataset.itemId));
                } else if (target.matches('.unequip-btn')) {
                    unequipItem(parseInt(target.dataset.mercId), target.dataset.slot);
                } else if (target.matches('#deploy-btn')) {
                    const mercSelect = document.getElementById('merc-select');
                    const location = gameState.map.locations[target.dataset.coord];
                    sendOnMission(parseInt(mercSelect.value), location.mission, target.dataset.coord, target);
                } else if (target.matches('#scout-btn')) {
                    scoutSector(target.dataset.coord, target);
                } else if (target.matches('#continue-btn')) {
                    if (spendResources({ energy: 100 }, target)) {
                        elements.gameOverOverlay.style.display = 'none';
                        renderAll();
                    }
                } else if (target.matches('#restart-btn')) {
                    location.reload();
                } else if (target.matches('.sudoku-cell') && !target.classList.contains('pre-filled')) {
                    sudokuState.selectedCell = { row: parseInt(target.dataset.row), col: parseInt(target.dataset.col) };
                    renderSudoku();
                } else if (target.matches('.sudoku-control-btn')) {
                    if (sudokuState.selectedCell) {
                        const { row, col } = sudokuState.selectedCell;
                        const num = parseInt(target.dataset.num);
                        sudokuState.board[row][col] = num === 0 ? 0 : -num; // Use negative for player numbers
                        renderSudoku();
                    }
                } else if (target.matches('#sudoku-check-btn')) {
                    const isCorrect = sudokuState.board.every((row, r) => row.every((cell, c) => Math.abs(cell) === sudokuState.solution[r][c]));
                    if (isCorrect) {
                        endSudokuMinigame(true);
                    } else {
                        sudokuState.lives--;
                        if (sudokuState.lives <= 0) {
                            endSudokuMinigame(false);
                        } else {
                            elements.sudokuLives.textContent = `Incorrect. Attempts Remaining: ${sudokuState.lives}`;
                        }
                    }
                } else if (target.matches('#sudoku-retreat-btn')) {
                    const retreatCost = { fuel: sudokuState.mission.cost.fuel * 2 };
                    if (hasEnoughResources(retreatCost)) {
                        elements.sudokuRetreatText.textContent = `Retreat for ${retreatCost.fuel} fuel?`;
                        elements.sudokuRetreatConfirm.style.display = 'block';
                    } else {
                        handleResourceShortage(retreatCost, target);
                    }
                } else if (target.matches('#confirm-retreat-btn')) {
                    const retreatCost = { fuel: sudokuState.mission.cost.fuel * 2 };
                    spendResources(retreatCost, target);
                    sudokuState.active = false;
                    elements.sudokuOverlay.style.display = 'none';
                    elements.sudokuRetreatConfirm.style.display = 'none';
                    renderAll();
                } else if (target.matches('#cancel-retreat-btn')) {
                    elements.sudokuRetreatConfirm.style.display = 'none';
                }
                else if (target.matches('#mission-success-close-btn')) {
                    elements.missionSuccessOverlay.style.display = 'none';
                }
            });

            elements.navButtons.forEach(button => button.addEventListener('click', () => { if (button.disabled) return; elements.navButtons.forEach(btn => btn.classList.remove('active')); elements.gameSections.forEach(sec => sec.classList.remove('active')); button.classList.add('active'); document.getElementById(`${button.dataset.tab}-section`).classList.add('active'); }));
            elements.mercFilterButtons.addEventListener('click', (e) => { if (e.target.tagName === 'BUTTON') { elements.mercFilterButtons.querySelectorAll('button').forEach(btn => btn.classList.remove('active')); e.target.classList.add('active'); renderMercs(e.target.dataset.filter); } });
            
            elements.modal.addEventListener('change', (e) => {
                if (e.target.matches('#merc-select')) {
                    const mercSelect = e.target;
                    const deployBtn = document.getElementById('deploy-btn');
                    if (deployBtn) {
                        const location = gameState.map.locations[deployBtn.dataset.coord];
                        const selectedMerc = getOperativeById(parseInt(mercSelect.value));
                        if (selectedMerc && location) {
                            if (selectedMerc.isCommander) {
                                document.getElementById('success-chance-p').textContent = 'Success determined by skill.';
                            } else {
                                const chance = getSuccessChance(getMercPower(selectedMerc), location.mission.difficulty);
                                document.getElementById('success-chance-p').textContent = `Success Chance: ${chance}%`;
                            }
                        }
                    }
                }
            });

            elements.closeButton.onclick = closeModal;
            window.onclick = (e) => { if (e.target == elements.modal) closeModal(); };
            
            renderAll();
            gameLoopInterval = setInterval(gameTick, 1000);
        }

        init();
    });
    </script>
</body>
</html>
