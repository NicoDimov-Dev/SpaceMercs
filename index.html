<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DeepSpaceMercs INC</title>
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-primary: #090a13;
            --bg-secondary: #181b25;
            --bg-tertiary: #23253a;
            --text-primary: #7afcff;
            --text-secondary: #46b7b9;
            --border-color: #274472;
            --accent-primary: #ff2a6d;
            --accent-hover: #bd1656;
            --accent-disabled: #31223d;
            --status-available: #23ce6b;
            --status-mission: #ffc600;
            --danger-color: #fe4a49;
            --font-family: 'Share Tech Mono', monospace;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: var(--font-family);
            background: #161a24;
            color: var(--text-primary);
            font-size: 15px;
            text-transform: uppercase;
            overflow: hidden;
        }
        
        /* --- CRT Filter Effects --- */
        .crt-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            border: 2px solid var(--border-color);
            padding: 15px;
            overflow: hidden;
            background: radial-gradient(ellipse at 50% 30%, #23253a 80%, #090a13 100%);
            border-radius: 20px; /* Screen curvature */
            display: flex;
            flex-direction: column;
        }
        .crt-container::before { /* Vignette */
            content: "";
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            box-shadow: inset 0 0 120px 30px rgba(0,0,0,0.75);
            pointer-events: none;
            z-index: 999;
        }
        .crt-container::after { /* Scanlines */
            content: "";
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: repeating-linear-gradient(
                0deg,
                rgba(18,255,255,0.06),
                rgba(18,255,255,0.08) 2px,
                transparent 2px,
                transparent 4px
            );
            mix-blend-mode: lighten;
            opacity: 0.37;
            animation: scanlines 0.25s linear infinite;
            pointer-events: none;
            z-index: 1000;
        }
        @keyframes scanlines {
            0% { background-position-y: 0; }
            100% { background-position-y: 8px; }
        }
        .crt-glow {
            text-shadow: 0 0 3px var(--text-primary);
        }
        /* --- End CRT Filter --- */
        
        header {
            text-align: center;
            padding: 5px 0 15px 0;
            border-bottom: 2px solid var(--border-color);
            flex-shrink: 0;
        }
        .header-title h1 { font-size: 36px; font-weight: 400; margin: 0; line-height: 1; color: var(--text-primary); }
        .header-title p { font-size: 18px; color: var(--text-secondary); margin: 0; }
        
        nav {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            padding: 10px 0;
            border-bottom: 2px solid var(--border-color);
            flex-shrink: 0;
        }
        .nav-button {
            background: none; border: none; color: var(--text-secondary);
            font-family: var(--font-family); font-size: 22px; cursor: pointer;
            text-transform: uppercase;
        }
        .nav-button:hover { color: var(--text-primary); }
        .nav-button.active { color: var(--accent-primary); }
        .nav-hint { color: var(--text-secondary); font-size: 18px; }

        .persistent-resource-bar {
            display: flex;
            justify-content: center;
            gap: 20px;
            padding: 10px 30px;
            background-color: var(--bg-secondary);
            border-bottom: 2px solid var(--border-color);
            flex-shrink: 0;
        }
        .resource-item { display: flex; align-items: center; gap: 8px; font-size: 16px; transition: color 0.3s; }
        .resource-item span { color: var(--accent-primary); }
        @keyframes red-glow { 0%, 100% { color: var(--text-primary); } 50% { color: var(--danger-color); } }
        .resource-glow { animation: red-glow 1s ease-in-out; }

        .page-container { padding: 30px; overflow-y: auto; flex-grow: 1; }
        .page-header { margin-bottom: 25px; }
        .page-header h1 { font-size: 28px; font-weight: 400; }
        .page-header p { color: var(--text-secondary); font-size: 16px; }
        .game-section { display: none; }
        .game-section.active { display: block; }
        .card { border: 2px solid var(--border-color); padding: 20px; margin-bottom: 20px; background: var(--bg-secondary); }
        h2 { font-size: 22px; font-weight: 400; border-bottom: 2px solid var(--border-color); padding-bottom: 5px; margin-bottom: 15px; }
        h3 { font-size: 18px; font-weight: 400; color: var(--text-primary); margin-bottom: 10px; }
        .table-container { border: 2px solid var(--border-color); }
        table { width: 100%; border-collapse: collapse; }
        th, td { padding: 15px; text-align: left; border-bottom: 2px solid var(--border-color); }
        th { color: var(--text-secondary); font-size: 16px; }
        tr:last-child td { border-bottom: none; }
        .status-tag { padding: 2px 6px; text-shadow: none; }
        .status-tag.available { background-color: var(--status-available); color: var(--bg-primary); }
        .status-tag.mission { background-color: var(--status-mission); color: var(--bg-primary); }
        .progress-bar { width: 100%; height: 10px; border: 2px solid var(--accent-primary); }
        .progress-bar-fill { height: 100%; background-color: var(--accent-primary); }
        button {
            background: none; color: var(--accent-primary); border: 2px solid var(--accent-primary);
            padding: 8px 15px; font-family: var(--font-family); font-size: 16px;
            cursor: pointer; text-transform: uppercase;
        }
        button:hover { background-color: var(--accent-primary); color: var(--bg-primary); }
        button:disabled { border-color: var(--text-secondary); color: var(--text-secondary); cursor: not-allowed; }
        button:disabled:hover { background: none; }
        .filter-buttons { display: flex; gap: 10px; margin-bottom: 20px; }
        .filter-buttons button { border: 2px solid var(--text-secondary); color: var(--text-secondary); }
        .filter-buttons button.active { border: 2px solid var(--accent-primary); color: var(--accent-primary); }
        .crafting-grid, .inventory-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); gap: 20px; }
        .recipe-card, .item-card { border: 2px solid var(--border-color); }
        .recipe-card img, .item-card img { width: 100%; height: 120px; object-fit: cover; background-color: #111; border-bottom: 2px solid var(--border-color); }
        .recipe-card-body, .item-card-body { padding: 15px; }
        .recipe-card-body h3, .item-card-body h3 { font-size: 20px; }
        .recipe-card-body p, .item-card-body p { font-size: 14px; color: var(--text-secondary); margin-bottom: 15px; }
        .recipe-card-body button { width: 100%; }
        #map-grid { display: grid; grid-template-columns: repeat(10, 1fr); grid-template-rows: repeat(8, 1fr); gap: 2px; width: 100%; height: 500px; border: 2px solid var(--border-color); background-color: #050505; }
        .map-tile { background-color: var(--bg-primary); cursor: pointer; transition: background-color 0.2s; display: flex; align-items: center; justify-content: center; font-size: 24px; color: var(--text-secondary); position: relative; }
        .map-tile:hover { background-color: var(--bg-tertiary); }
        .map-tile.unlocked { color: var(--text-primary); }
        .map-tile .progress-ring { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%) rotate(-90deg); width: 80%; height: 80%; }
        .map-tile .progress-ring__circle { transition: stroke-dashoffset 0.35s; stroke: var(--text-primary); stroke-width: 4; fill: transparent; }
        .modal { display: none; position: fixed; z-index: 2000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.8); }
        .modal-content { background-color: var(--bg-secondary); border: 2px solid var(--border-color); margin: 10% auto; padding: 25px; width: 90%; max-width: 600px; }
        .close-button { color: var(--text-secondary); float: right; font-size: 28px; font-weight: bold; cursor: pointer; }
        .close-button:hover { color: var(--text-primary); }
        #game-over-overlay, #minigame-overlay, #shooter-overlay { display: none; position: fixed; z-index: 3000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.95); justify-content: center; align-items: center; text-align: center; }
        #game-over-overlay h1, #minigame-overlay h1, #shooter-overlay h1 { font-size: 48px; color: var(--danger-color); }
        #game-over-overlay p, #minigame-overlay p, #shooter-overlay p { font-size: 24px; color: var(--text-primary); }
        #minigame-canvas, #shooter-canvas { background: #000; border: 2px solid var(--accent-primary); }
        .equipment-slot { display: flex; justify-content: space-between; align-items: center; padding: 10px; border: 2px solid var(--border-color); margin-bottom: 10px; }
        .action-tooltip { position: absolute; transform: translateY(-110%); background-color: var(--danger-color); color: white; padding: 8px 12px; font-size: 16px; font-weight: 400; z-index: 2100; white-space: nowrap; border: 2px solid white; text-shadow: none; }
        footer {
            border-top: 2px solid var(--border-color);
            padding: 5px 15px;
            margin-top: 10px;
            font-size: 14px;
            color: var(--text-secondary);
            text-align: center;
            flex-shrink: 0;
        }
    </style>
</head>
<body class="crt-glow">

    <div class="crt"></div>
    <div id="game-over-overlay">
        <div><h1>MISSION FAILED</h1><p>The Commander has fallen. The operation is over.</p></div>
    </div>
    <div id="minigame-overlay">
        <div>
            <h1 id="minigame-title">INCOMING TRANSMISSION...</h1>
            <p id="minigame-subtitle">Clear the data blocks to succeed.</p>
            <canvas id="minigame-canvas" width="480" height="320"></canvas>
        </div>
    </div>
    <div id="shooter-overlay">
        <div>
            <h1 id="shooter-title">HOSTILE TERRITORY</h1>
            <p id="shooter-subtitle">SCORE <span id="shooter-target-score">0</span> TO SUCCEED</p>
            <canvas id="shooter-canvas" width="400" height="600"></canvas>
        </div>
    </div>

    <div class="crt-container">
        <header>
            <div class="header-title">
                <h1>DeepSpaceMercs INC</h1>
                <p>by NicoDimov</p>
            </div>
        </header>

        <nav id="main-nav">
            <span class="nav-hint">[LB]</span>
            <button class="nav-button active" data-tab="base">Dashboard</button>
            <button class="nav-button" data-tab="commander">Commander</button>
            <button class="nav-button" data-tab="mercs">Operatives</button>
            <button class="nav-button" data-tab="recruitment">Recruit</button>
            <button class="nav-button" data-tab="inventory">Inventory</button>
            <button class="nav-button" data-tab="map">Starmap</button>
            <button class="nav-button" data-tab="crafting">Fabricator</button>
            <span class="nav-hint">[RB]</span>
        </nav>
        
        <div id="persistent-resource-bar" class="persistent-resource-bar"></div>

        <main id="main-content" class="page-container">
            <section id="base-section" class="game-section active"><div class="page-header"><h1>Command Dashboard</h1><p>System overview of your orbital platform.</p></div><h2>Fabrication Queue</h2><div class="table-container" id="production-queue-table"></div><h2 style="margin-top: 30px;">Active Missions</h2><div class="table-container" id="active-missions-table"></div></section>
            <section id="commander-section" class="game-section"></section>
            <section id="mercs-section" class="game-section"><div class="page-header"><h1>Operative Roster</h1><p>Manage your elite crew.</p></div><div class="filter-buttons" id="merc-filter-buttons"><button class="active" data-filter="all">All</button><button data-filter="available">Available</button><button data-filter="mission">On Mission</button></div><div class="table-container" id="merc-list-table"></div></section>
            <section id="recruitment-section" class="game-section"><div class="page-header"><h1>Recruitment Center</h1><p>Hire new operatives from across the galaxy.</p></div><div class="card"><h2>Hire Operative</h2><p>Find new talent to join your cause. Each operative brings a unique set of skills.</p><button id="recruit-merc-btn">Hire Operative (1500 Credits)</button></div></section>
            <section id="inventory-section" class="game-section"><div class="page-header"><h1>Inventory</h1><p>All fabricated equipment and consumables are stored here.</p></div><div id="inventory-container" class="inventory-grid"></div></section>
            <section id="map-section" class="game-section"><div class="page-header"><h1>Starmap</h1><p>Chart the void. Click a sector to view details and deploy a team.</p></div><div id="map-grid"></div></section>
            <section id="crafting-section" class="game-section"><div class="page-header"><h1>Fabricator</h1><p>Use materials to fabricate equipment and research new technologies.</p></div><div id="crafting-recipes-container"></div></section>
        </main>
        
         <footer>
            <p>Copyright 2984, NicoDimov Corp. All rights reserved. Any unauthorized duplication, distribution, or lobotomization of our intellectual property is strictly prohibited and punishable by immediate termination of your neural license.</p>
        </footer>
    </div>

    <div id="main-modal" class="modal"><div class="modal-content"><span class="close-button">&times;</span><h2 id="modal-title"></h2><div id="modal-body"></div></div></div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {

        let gameLoopInterval = null;

        const gameState = {
            resources: { food: 500, fuel: 250, materials: 1000, credits: 2500, energy: 300, scoutDrones: 1 },
            inventory: [
                { id: 1, name: 'Med-Syringe', type: 'utility', power: 5, img: 'https://placehold.co/400x240/1e1e1e/e0e0e0?text=Med-Syringe' },
                { id: 2, name: 'Pulse Rifle', type: 'weapon', power: 30, img: 'https://placehold.co/400x240/1e1e1e/e0e0e0?text=Pulse+Rifle' }
            ],
            commander: { id: 0, name: 'Commander', class: 'Strategist', level: 1, isCommander: true, equipment: { weapon: null, armor: null, utility: null } },
            mercenaries: [],
            missions: { active: [] },
            crafting: {
                queue: [],
                recipes: [
                    { id: 'fuel_cell', name: 'Stabilized Fuel Cell', cost: { materials: 50, energy: 25 }, time: 20, category: 'Consumables', type: 'fuel', isUnlocked: true, img: 'https://placehold.co/400x240/1e1e1e/e0e0e0?text=Fuel+Cell' },
                    { id: 'medkit', name: 'Med-Syringe', cost: { materials: 25 }, time: 10, category: 'Consumables', type: 'utility', power: 5, isUnlocked: true, img: 'https://placehold.co/400x240/1e1e1e/e0e0e0?text=Med-Syringe' },
                    { id: 'armor1', name: 'Exo-Armor Plating', cost: { materials: 150 }, time: 60, category: 'Armor', type: 'armor', power: 20, isUnlocked: true, img: 'https://placehold.co/400x240/1e1e1e/e0e0e0?text=Exo-Armor' },
                    { id: 'rifle1', name: 'Pulse Rifle', cost: { materials: 200, energy: 25 }, time: 90, category: 'Weapons', type: 'weapon', power: 30, isUnlocked: true, img: 'https://placehold.co/400x240/1e1e1e/e0e0e0?text=Pulse+Rifle' },
                    { id: 'scout_drone', name: 'Scout Drone', cost: { materials: 300, energy: 100 }, time: 30, category: 'Tools', type: 'drone', isUnlocked: true, img: 'https://placehold.co/400x240/1e1e1e/e0e0e0?text=Scout+Drone' },
                    { id: 'research_armor2', name: 'Advanced Plating R&D', cost: { materials: 500, credits: 1000 }, time: 300, category: 'R&D', type: 'research', unlocks: 'armor2', isUnlocked: true, img: 'https://placehold.co/400x240/1e1e1e/e0e0e0?text=R&D:+Armor' },
                    { id: 'armor2', name: 'Aegis Armor', cost: { materials: 400, energy: 50 }, time: 180, category: 'Armor', type: 'armor', power: 50, isUnlocked: false, img: 'https://placehold.co/400x240/1e1e1e/e0e0e0?text=Aegis+Armor' },
                ]
            },
            map: { locations: { 
                '2,2': { name: 'Derelict Freighter', status: 'idle', mission: { id: 'salvage_freighter', name: 'Salvage Freighter', difficulty: 20, cost: { fuel: 20 }, duration: 60, rewards: { materials: 200, credits: 500 } } }, 
                '5,4': { name: 'Asteroid Cluster', status: 'idle', mission: { id: 'mine_asteroids', name: 'Mine Asteroids', difficulty: 40, cost: { fuel: 30 }, duration: 120, rewards: { materials: 400, energy: 50 } } },
                '7,7': { name: 'Gas Cloud', status: 'idle', mission: { id: 'harvest_gas', name: 'Harvest I-Gels', difficulty: 10, cost: { fuel: 5 }, duration: 30, rewards: { fuel: 50 } } }
            } },
            nextMercId: 1,
            nextItemId: 3,
            mercNames: ["Jax", "Vex", "Kira", "Zane", "Nyx", "Roric"],
            mercClasses: ["Marksman", "Vanguard", "Medic", "Technician", "Ghost"],
        };
        
        const elements = {
            mainContent: document.getElementById('main-content'),
            navButtons: document.querySelectorAll('.nav-button'),
            gameSections: document.querySelectorAll('.game-section'),
            resourceBar: document.getElementById('persistent-resource-bar'),
            productionQueueTable: document.getElementById('production-queue-table'),
            activeMissionsTable: document.getElementById('active-missions-table'),
            commanderSection: document.getElementById('commander-section'),
            mercFilterButtons: document.getElementById('merc-filter-buttons'),
            mercListTable: document.getElementById('merc-list-table'),
            inventoryContainer: document.getElementById('inventory-container'),
            craftingRecipesContainer: document.getElementById('crafting-recipes-container'),
            mapGrid: document.getElementById('map-grid'),
            modal: document.getElementById('main-modal'),
            modalTitle: document.getElementById('modal-title'),
            modalBody: document.getElementById('modal-body'),
            closeButton: document.querySelector('.close-button'),
            gameOverOverlay: document.getElementById('game-over-overlay'),
            minigameOverlay: document.getElementById('minigame-overlay'),
            minigameCanvas: document.getElementById('minigame-canvas'),
            shooterOverlay: document.getElementById('shooter-overlay'),
            shooterCanvas: document.getElementById('shooter-canvas'),
            shooterTargetScore: document.getElementById('shooter-target-score'),
        };

        // --- Minigame States & Logic ---
        let breakoutState = {
            active: false,
            animationFrame: null,
            mission: null,
            ball: { x: 0, y: 0, dx: 2, dy: -2, radius: 7 },
            paddle: { height: 10, width: 75, x: 0 },
            bricks: [],
            score: 0,
            lives: 3
        };

        let shooterState = {
            active: false,
            animationFrame: null,
            mission: null,
            targetScore: 0,
            player: { width: 30, height: 30, x: 0, y: 0, speed: 4, dx: 0 },
            bullets: [],
            enemies: [],
            enemyBullets: [],
            stars: [],
            framesSincePlayerShot: 0,
            framesSinceSpawn: 0,
            lives: 3,
            score: 0,
            keys: { right: false, left: false, space: false }
        };

        const getOperativeById = (id) => [gameState.commander, ...gameState.mercenaries].find(op => op.id === id);
        const getMercPower = (merc) => { let power = merc.level * 10; for (const slot in merc.equipment) { if (merc.equipment[slot]) { power += merc.equipment[slot].power; } } return power; };
        const getSuccessChance = (power, difficulty) => Math.round(Math.min(95, 50 + (power - difficulty) * 1.5));
        const hasEnoughResources = (cost) => Object.entries(cost).every(([r, a]) => gameState.resources[r] >= a);
        const addResources = (rewards) => { Object.entries(rewards).forEach(([r, a]) => { if(gameState.resources[r] !== undefined) gameState.resources[r] += a; }); };
        
        function handleResourceShortage(cost, element) {
            const missing = Object.entries(cost).filter(([res, amount]) => gameState.resources[res] < amount);
            missing.forEach(([res]) => {
                const resElement = document.getElementById(`resource-${res}`);
                if (resElement) {
                    resElement.classList.add('resource-glow');
                    setTimeout(() => resElement.classList.remove('resource-glow'), 1000);
                }
            });
            const tooltip = document.createElement('div');
            tooltip.className = 'action-tooltip';
            tooltip.textContent = 'Missing: ' + missing.map(([res, amount]) => `${amount - gameState.resources[res]} ${res}`).join(', ');
            document.body.appendChild(tooltip);
            const btnRect = element.getBoundingClientRect();
            tooltip.style.left = `${btnRect.left + window.scrollX}px`;
            tooltip.style.top = `${btnRect.top + window.scrollY}px`;
            setTimeout(() => tooltip.remove(), 2000);
        }

        const spendResources = (cost, element) => { 
            if (hasEnoughResources(cost)) {
                Object.entries(cost).forEach(([r, a]) => gameState.resources[r] -= a);
                return true;
            }
            handleResourceShortage(cost, element);
            return false;
        };

        function renderAll() { renderResources(); renderProductionQueue(); renderCommander(); renderMercs(); renderCrafting(); renderActiveMissions(); renderMap(); renderInventory(); }
        function renderResources() { elements.resourceBar.innerHTML = Object.entries(gameState.resources).map(([name, value]) => `<div class="resource-item" id="resource-${name}">${name.replace(/([A-Z])/g, ' $1')}: <span>${value.toLocaleString()}</span></div>`).join(''); }
        function renderProductionQueue() {
            let content = '<table><tbody><tr><td style="text-align: center; color: var(--text-secondary);">No active fabrication jobs.</td></tr></tbody></table>';
            if (gameState.crafting.queue.length > 0) { content = `<table><thead><tr><th>Item</th><th>Time Left</th><th>Progress</th></tr></thead><tbody>${gameState.crafting.queue.map(item => `<tr><td>${item.name}</td><td>${item.timeLeft}s</td><td><div class="progress-bar"><div class="progress-bar-fill" style="width: ${((item.time - item.timeLeft) / item.time) * 100}%"></div></div></td></tr>`).join('')}</tbody></table>`; }
            elements.productionQueueTable.innerHTML = content;
        }
        function renderCommander() {
            const commander = gameState.commander;
            elements.commanderSection.innerHTML = `<div class="page-header"><h1>Commander Profile</h1></div><div class="card"><h2>${commander.name}</h2><p>Class: ${commander.class} // Level: ${commander.level} // Power: ${getMercPower(commander)}</p></div><div class="card"><h2>Equipment</h2><div id="commander-equipment"></div></div>`;
            renderEquipment(commander, document.getElementById('commander-equipment'));
        }
        function renderMercs(filter = 'all') {
            const filtered = gameState.mercenaries.filter(merc => {
                const isOnMission = gameState.missions.active.some(m => m.mercId === merc.id);
                if (filter === 'available') return !isOnMission; if (filter === 'mission') return isOnMission; return true;
            });
            let content = '<table><tbody><tr><td style="text-align: center; color: var(--text-secondary);">No operatives match filter.</td></tr></tbody></table>';
            if (filtered.length > 0) {
                content = `<table><thead><tr><th>Name</th><th>Class</th><th>Level</th><th>Power</th><th>Status</th><th></th></tr></thead><tbody>
                    ${filtered.map(merc => `<tr><td>${merc.name}</td><td>${merc.class}</td><td>${merc.level}</td><td>${getMercPower(merc)}</td>
                    <td><span class="status-tag ${gameState.missions.active.some(m=>m.mercId===merc.id) ? 'mission' : 'available'}">${gameState.missions.active.some(m=>m.mercId===merc.id) ? 'On Mission' : 'Available'}</span></td>
                    <td><button class="view-profile-btn" data-merc-id="${merc.id}">View Profile</button></td></tr>`).join('')}</tbody></table>`;
            }
            elements.mercListTable.innerHTML = content;
        }
        function renderCrafting() {
            const categories = [...new Set(gameState.crafting.recipes.map(r => r.category))];
            elements.craftingRecipesContainer.innerHTML = categories.map(cat => `<div><h2>${cat}</h2><div class="crafting-grid">${gameState.crafting.recipes.filter(r => r.category === cat && r.isUnlocked).map(recipe => {
                const queuedItem = gameState.crafting.queue.find(item => item.id === recipe.id);
                const isInQueue = !!queuedItem;
                return `<div class="recipe-card"><img src="${recipe.img}" alt="${recipe.name}"><div class="recipe-card-body"><h3>${recipe.name}</h3><p>${Object.entries(recipe.cost).map(([r,c])=>`${c} ${r}`).join(', ')} // ${recipe.time}s</p><button class="craft-btn" data-recipe-id="${recipe.id}" ${isInQueue ? 'disabled' : ''}>${isInQueue ? `IN QUEUE [${queuedItem.timeLeft}s]` : (recipe.type === 'research' ? 'Research' : 'Fabricate')}</button></div></div>`
            }).join('')}</div></div>`).join('');
        }
        function renderInventory() {
            if (gameState.inventory.length === 0) {
                elements.inventoryContainer.innerHTML = `<p style="color: var(--text-secondary);">Your inventory is empty. Fabricate items to see them here.</p>`;
                return;
            }
            elements.inventoryContainer.innerHTML = gameState.inventory.map(item => `<div class="item-card"><img src="${item.img}" alt="${item.name}"><div class="item-card-body"><h3>${item.name}</h3><p>Type: ${item.type} // Power: ${item.power}</p></div></div>`).join('');
        }
        function renderActiveMissions() {
            let content = '<table><tbody><tr><td style="text-align: center; color: var(--text-secondary);">No missions in progress.</td></tr></tbody></table>';
            if (gameState.missions.active.length > 0) { content = `<table><thead><tr><th>Mission</th><th>Operative</th><th>Time Left</th><th>Progress</th></tr></thead><tbody>${gameState.missions.active.map(mission => `<tr><td>${mission.name}</td><td>${mission.mercId !== null ? getOperativeById(mission.mercId).name : 'Drone'}</td><td>${mission.timeLeft}s</td><td><div class="progress-bar"><div class="progress-bar-fill" style="width: ${((mission.duration - mission.timeLeft) / mission.duration) * 100}%"></div></div></td></tr>`).join('')}</tbody></table>`; }
            elements.activeMissionsTable.innerHTML = content;
        }
        function renderMap() {
            elements.mapGrid.innerHTML = '';
            for (let r = 0; r < 8; r++) { for (let c = 0; c < 10; c++) {
                const coord = `${r},${c}`;
                const tile = document.createElement('div');
                tile.className = 'map-tile';
                tile.dataset.coord = coord;
                const location = gameState.map.locations[coord];
                const activeMission = gameState.missions.active.find(m => m.coord === coord);
                let content = '·';
                if (location) { tile.classList.add('unlocked'); content = '★'; }
                if (activeMission) {
                    const progress = (activeMission.duration - activeMission.timeLeft) / activeMission.duration;
                    const radius = 18;
                    const circumference = 2 * Math.PI * radius;
                    const offset = circumference - progress * circumference;
                    content += `<svg class="progress-ring" viewBox="0 0 40 40"><circle class="progress-ring__circle" r="${radius}" cx="20" cy="20" style="stroke-dasharray: ${circumference}; stroke-dashoffset: ${offset};"></circle></svg>`;
                }
                tile.innerHTML = content;
                elements.mapGrid.appendChild(tile);
            } }
        }
        function renderEquipment(merc, container) {
            container.innerHTML = Object.keys(merc.equipment).map(slot => `<div class="equipment-slot"><span><strong>${slot.toUpperCase()}:</strong> ${merc.equipment[slot] ? `${merc.equipment[slot].name} (Pwr: ${merc.equipment[slot].power})` : 'Empty'}</span><button class="equip-btn" data-merc-id="${merc.id}" data-slot="${slot}">${merc.equipment[slot] ? 'Change' : 'Equip'}</button></div>`).join('');
        }
        
        function showLocationModal(coord) {
            const location = gameState.map.locations[coord];
            const activeMission = gameState.missions.active.find(m => m.coord === coord);
            elements.modalTitle.textContent = location ? location.name : `Uncharted Sector [${coord}]`;
            let body = '';
            if (activeMission) { body = `<p>A mission is already underway in this sector.</p><p>Time Remaining: ${activeMission.timeLeft}s</p>`; }
            else if (location) {
                const availableMercs = [gameState.commander, ...gameState.mercenaries].filter(m => !gameState.missions.active.some(mis => mis.mercId === m.id));
                let mercSelectorHTML = '<p>No available operatives.</p>';
                if (availableMercs.length > 0) {
                    mercSelectorHTML = `<label for="merc-select" style="display:block; margin-bottom:10px;">Assign Operative:</label><select id="merc-select" style="width: 100%; padding: 8px; margin-bottom: 15px; background: #000; color: #fff; border: 2px solid #fff; font-family: var(--font-family); font-size: 18px;">${availableMercs.map(m => `<option value="${m.id}">${m.name} (Pwr: ${getMercPower(m)})</option>`).join('')}</select><p id="success-chance-p"></p><button id="deploy-btn" data-coord="${coord}">Deploy</button>`;
                }
                body = `<p><strong>Mission:</strong> ${location.mission.name}</p><p><strong>Difficulty:</strong> ${location.mission.difficulty}</p><p><strong>Cost:</strong> ${Object.entries(location.mission.cost).map(([r,v])=>`${v} ${r}`).join(', ')}</p><p><strong>Rewards:</strong> ${Object.entries(location.mission.rewards).map(([r,v])=>`${v} ${r}`).join(', ')}</p><hr style="border-color: var(--border-color); margin: 15px 0;">${mercSelectorHTML}`;
            } else {
                body = `<p>This sector is a mystery.</p>`;
                if (gameState.resources.scoutDrones > 0) { body += `<p>You have ${gameState.resources.scoutDrones} Scout Drone(s) available.</p><button id="scout-btn" data-coord="${coord}">Deploy Scout Drone // 10 Fuel, 30s</button>`; }
                else { body += `<p>Fabricate more Scout Drones to explore uncharted space.</p>`; }
            }
            elements.modalBody.innerHTML = body;
            elements.modal.style.display = 'block';

            const mercSelect = document.getElementById('merc-select');
            if (mercSelect) {
                const updateSuccessChance = () => {
                    const location = gameState.map.locations[coord];
                    const selectedMerc = getOperativeById(parseInt(mercSelect.value));
                    if (selectedMerc && location) {
                        if (selectedMerc.isCommander) {
                            document.getElementById('success-chance-p').textContent = 'Success determined by skill.';
                        } else {
                            const chance = getSuccessChance(getMercPower(selectedMerc), location.mission.difficulty);
                            document.getElementById('success-chance-p').textContent = `Success Chance: ${chance}%`;
                        }
                    }
                };
                updateSuccessChance();
                mercSelect.onchange = updateSuccessChance;
            }
        }
        function showMercProfileModal(mercId) {
            const merc = getOperativeById(mercId);
            if (!merc) return;
            elements.modalTitle.textContent = `Profile: ${merc.name}`;
            elements.modalBody.innerHTML = `<div class="card"><h2>${merc.name}</h2><p>Class: ${merc.class} // Level: ${merc.level} // Power: ${getMercPower(merc)}</p></div><div class="card"><h2>Equipment</h2><div id="merc-equipment-container"></div></div>`;
            renderEquipment(merc, document.getElementById('merc-equipment-container'));
            elements.modal.style.display = 'block';
        }
        function showEquipmentModal(mercId, slot) {
            const merc = getOperativeById(mercId);
            const compatibleItems = gameState.inventory.filter(item => item.type === slot);
            elements.modalTitle.textContent = `Equip ${slot.toUpperCase()}`;
            let body = '<p>No compatible items in inventory.</p>';
            if (compatibleItems.length > 0) { body = compatibleItems.map(item => `<div class="equipment-slot"><span>${item.name} (Pwr: ${item.power})</span><button class="equip-item-btn" data-item-id="${item.id}" data-merc-id="${mercId}" data-slot="${slot}">Equip</button></div>`).join(''); }
            body += `<hr style="border-color: var(--border-color); margin: 15px 0;"><button class="unequip-btn" data-merc-id="${mercId}" data-slot="${slot}">Unequip Slot</button>`;
            elements.modalBody.innerHTML = body;
            elements.modal.style.display = 'block';
        }
        function closeModal() { elements.modal.style.display = 'none'; }

        function sendOnMission(mercId, missionTemplate, coord, element) {
            if (mercId === 0) { // Commander's ID is 0
                if (spendResources(missionTemplate.cost, element)) {
                    closeModal();
                    if (Math.random() < 0.5) {
                        startMinigame(missionTemplate);
                    } else {
                        startShooterMinigame(missionTemplate);
                    }
                }
            } else {
                if (spendResources(missionTemplate.cost, element)) { 
                    gameState.missions.active.push({ ...missionTemplate, mercId, timeLeft: missionTemplate.duration, coord }); 
                    closeModal(); 
                    renderAll(); 
                }
            }
        }
        function scoutSector(coord, element) { if (spendResources({ fuel: 10 }, element)) { gameState.resources.scoutDrones--; gameState.missions.active.push({ id: 'scout_mission', name: `Scouting ${coord}`, type: 'scout', timeLeft: 30, duration: 30, coord, mercId: null }); closeModal(); renderAll(); } }
        function recruitMerc(element) { if (spendResources({ credits: 1500 }, element)) { gameState.mercenaries.push({ id: gameState.nextMercId++, name: gameState.mercNames[Math.floor(Math.random() * gameState.mercNames.length)], class: gameState.mercClasses[Math.floor(Math.random() * gameState.mercClasses.length)], level: 1, equipment: { weapon: null, armor: null, utility: null } }); renderAll(); } }
        function craftItem(recipeId, element) {
            const recipe = gameState.crafting.recipes.find(r => r.id === recipeId);
            if (recipe && !gameState.crafting.queue.some(item => item.id === recipeId) && spendResources(recipe.cost, element)) {
                gameState.crafting.queue.push({ ...recipe, timeLeft: recipe.time });
                renderCrafting();
                renderProductionQueue();
            }
        }
        function equipItem(mercId, slot, itemId) {
            const merc = getOperativeById(mercId);
            const itemIndex = gameState.inventory.findIndex(i => i.id === itemId);
            if (!merc || itemIndex === -1) return;
            if (merc.equipment[slot]) { gameState.inventory.push(merc.equipment[slot]); }
            merc.equipment[slot] = gameState.inventory[itemIndex];
            gameState.inventory.splice(itemIndex, 1);
            closeModal();
            renderAll();
        }
        function unequipItem(mercId, slot) {
            const merc = getOperativeById(mercId);
            if (!merc || !merc.equipment[slot]) return;
            gameState.inventory.push(merc.equipment[slot]);
            merc.equipment[slot] = null;
            closeModal();
            renderAll();
        }
        function gameOver() { clearInterval(gameLoopInterval); elements.gameOverOverlay.style.display = 'flex'; }

        function startMinigame(mission) {
            breakoutState.active = true;
            breakoutState.mission = mission;
            elements.minigameOverlay.style.display = 'flex';
            
            const canvas = elements.minigameCanvas;
            breakoutState.ball.x = canvas.width / 2;
            breakoutState.ball.y = canvas.height - 30;
            breakoutState.paddle.x = (canvas.width - breakoutState.paddle.width) / 2;
            breakoutState.lives = 3;
            breakoutState.score = 0;

            const brickRowCount = 3 + Math.floor(mission.difficulty / 20);
            const brickColumnCount = 5;
            breakoutState.bricks = [];
            for (let c = 0; c < brickColumnCount; c++) {
                breakoutState.bricks[c] = [];
                for (let r = 0; r < brickRowCount; r++) {
                    breakoutState.bricks[c][r] = { x: 0, y: 0, status: 1 };
                }
            }

            if(breakoutState.animationFrame) cancelAnimationFrame(breakoutState.animationFrame);
            breakoutLoop();
        }

        function endMinigame(isWin) {
            breakoutState.active = false;
            cancelAnimationFrame(breakoutState.animationFrame);
            elements.minigameOverlay.style.display = 'none';

            if (isWin) {
                addResources(breakoutState.mission.rewards);
                gameState.commander.level++;
                renderAll();
            } else {
                gameOver();
            }
            breakoutState.mission = null;
        }

        function breakoutLoop() {
            if (!breakoutState.active) return;
            const canvas = elements.minigameCanvas;
            const ctx = canvas.getContext('2d');
            const { ball, paddle, bricks } = breakoutState;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            let bricksLeft = 0;
            for (let c = 0; c < bricks.length; c++) {
                for (let r = 0; r < bricks[c].length; r++) {
                    if (bricks[c][r].status === 1) {
                        bricksLeft++;
                        let brickX = (c * (75 + 10)) + 30;
                        let brickY = (r * (20 + 10)) + 30;
                        bricks[c][r].x = brickX;
                        bricks[c][r].y = brickY;
                        ctx.beginPath();
                        ctx.rect(brickX, brickY, 75, 20);
                        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent-primary');
                        ctx.fill();
                        ctx.closePath();
                    }
                }
            }

            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--text-primary');
            ctx.fill();
            ctx.closePath();

            ctx.beginPath();
            ctx.rect(paddle.x, canvas.height - paddle.height, paddle.width, paddle.height);
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent-primary');
            ctx.fill();
            ctx.closePath();

            ctx.font = "16px 'Share Tech Mono'";
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--text-primary');
            ctx.fillText("SCORE: " + breakoutState.score, 8, 20);
            ctx.fillText("LIVES: " + breakoutState.lives, canvas.width - 85, 20);

            for (let c = 0; c < bricks.length; c++) {
                for (let r = 0; r < bricks[c].length; r++) {
                    let b = bricks[c][r];
                    if (b.status === 1) {
                        if (ball.x > b.x && ball.x < b.x + 75 && ball.y > b.y && ball.y < b.y + 20) {
                            ball.dy = -ball.dy;
                            b.status = 0;
                            breakoutState.score++;
                            if (breakoutState.score === bricks.length * bricks[0].length) {
                                endMinigame(true);
                                return;
                            }
                        }
                    }
                }
            }
            
            if (ball.x + ball.dx > canvas.width - ball.radius || ball.x + ball.dx < ball.radius) {
                ball.dx = -ball.dx;
            }
            if (ball.y + ball.dy < ball.radius) {
                ball.dy = -ball.dy;
            } else if (ball.y + ball.dy > canvas.height - ball.radius) {
                if (ball.x > paddle.x && ball.x < paddle.x + paddle.width) {
                    ball.dy = -ball.dy;
                } else {
                    breakoutState.lives--;
                    if (!breakoutState.lives) {
                        endMinigame(false);
                        return;
                    } else {
                        ball.x = canvas.width / 2;
                        ball.y = canvas.height - 30;
                        ball.dx = 2;
                        ball.dy = -2;
                        paddle.x = (canvas.width - paddle.width) / 2;
                    }
                }
            }

            ball.x += ball.dx;
            ball.y += ball.dy;

            breakoutState.animationFrame = requestAnimationFrame(breakoutLoop);
        }

        function startShooterMinigame(mission) {
            shooterState.active = true;
            shooterState.mission = mission;
            elements.shooterOverlay.style.display = 'flex';
            
            const canvas = elements.shooterCanvas;
            shooterState.player.x = canvas.width / 2 - shooterState.player.width / 2;
            shooterState.player.y = canvas.height - 60;
            shooterState.score = 0;
            shooterState.targetScore = 500 + mission.difficulty * 25;
            elements.shooterTargetScore.textContent = shooterState.targetScore;
            
            let armorPower = gameState.commander.equipment.armor ? gameState.commander.equipment.armor.power : 0;
            shooterState.lives = 2 + Math.floor(armorPower / 20);

            shooterState.enemies = [];
            shooterState.bullets = [];
            shooterState.enemyBullets = [];
            shooterState.framesSinceSpawn = 0;
            
            shooterState.stars = [];
            for (let i = 0; i < 100; i++) {
                shooterState.stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    radius: Math.random() * 1.5,
                    speed: Math.random() * 3 + 1
                });
            }

            if(shooterState.animationFrame) cancelAnimationFrame(shooterState.animationFrame);
            shooterLoop();
        }

        function endShooterMinigame(isWin) {
            shooterState.active = false;
            cancelAnimationFrame(shooterState.animationFrame);
            elements.shooterOverlay.style.display = 'none';

            if (isWin) {
                addResources(shooterState.mission.rewards);
                gameState.commander.level++;
                renderAll();
            } else {
                gameOver();
            }
            shooterState.mission = null;
        }

        function shooterLoop() {
            if (!shooterState.active) return;
            
            updateShooter();
            drawShooter();

            shooterState.animationFrame = requestAnimationFrame(shooterLoop);
        }

        function updateShooter() {
            const { player, enemies, bullets, enemyBullets, keys, stars } = shooterState;
            const canvas = elements.shooterCanvas;

            // Update Stars
            for(const star of stars) {
                star.y += star.speed;
                if (star.y > canvas.height) {
                    star.y = 0;
                    star.x = Math.random() * canvas.width;
                }
            }

            // Player Movement
            player.dx = 0;
            if (keys.right) player.dx = player.speed;
            if (keys.left) player.dx = -player.speed;
            player.x += player.dx;
            if (player.x < 0) player.x = 0;
            if (player.x + player.width > canvas.width) player.x = canvas.width - player.width;

            // Player Firing
            shooterState.framesSincePlayerShot++;
            if (keys.space && shooterState.framesSincePlayerShot >= 15) {
                bullets.push({ x: player.x + player.width / 2 - 2.5, y: player.y, width: 5, height: 10 });
                shooterState.framesSincePlayerShot = 0;
            }

            // Update Bullets
            for (let i = bullets.length - 1; i >= 0; i--) {
                bullets[i].y -= 7;
                if (bullets[i].y < 0) bullets.splice(i, 1);
            }

            // Enemy Spawning
            shooterState.framesSinceSpawn++;
            if (shooterState.framesSinceSpawn >= 100) {
                const startX = Math.random() * (canvas.width - 40);
                enemies.push({ x: startX, y: -40, width: 40, height: 30, initialX: startX, fireCooldown: Math.random() * 120 + 60, framesSinceFired: 0 });
                shooterState.framesSinceSpawn = 0;
            }

            // Update Enemies
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                enemy.y += 1.5;
                enemy.x = enemy.initialX + Math.sin(enemy.y / 50) * 40;
                enemy.framesSinceFired++;
                if(enemy.framesSinceFired >= enemy.fireCooldown) {
                    enemyBullets.push({ x: enemy.x + enemy.width / 2 - 2.5, y: enemy.y + enemy.height, width: 5, height: 10 });
                    enemy.framesSinceFired = 0;
                }
                if (enemy.y > canvas.height) enemies.splice(i, 1);
            }

            // Update Enemy Bullets
            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                enemyBullets[i].y += 3;
                if (enemyBullets[i].y > canvas.height) enemyBullets.splice(i, 1);
            }

            // Collision: Player Bullets vs Enemies
            for (let i = bullets.length - 1; i >= 0; i--) {
                for (let j = enemies.length - 1; j >= 0; j--) {
                    if (!bullets[i]) continue;
                    if (bullets[i].x < enemies[j].x + enemies[j].width && bullets[i].x + bullets[i].width > enemies[j].x && bullets[i].y < enemies[j].y + enemies[j].height && bullets[i].y + bullets[i].height > enemies[j].y) {
                        bullets.splice(i, 1);
                        enemies.splice(j, 1);
                        shooterState.score += 50;
                        if (shooterState.score >= shooterState.targetScore) {
                            endShooterMinigame(true);
                            return;
                        }
                        break;
                    }
                }
            }
            
            // Collision: Player vs Enemies or Enemy Bullets
            const checkPlayerCollision = (thing) => player.x < thing.x + thing.width && player.x + player.width > thing.x && player.y < thing.y + thing.height && player.y + player.height > thing.y;
            
            for (const enemy of enemies) {
                if (checkPlayerCollision(enemy)) {
                    shooterState.lives--;
                    enemies.splice(enemies.indexOf(enemy), 1);
                    if (shooterState.lives <= 0) { endShooterMinigame(false); return; }
                }
            }
            for (const bullet of enemyBullets) {
                if (checkPlayerCollision(bullet)) {
                    shooterState.lives--;
                    enemyBullets.splice(enemyBullets.indexOf(bullet), 1);
                    if (shooterState.lives <= 0) { endShooterMinigame(false); return; }
                }
            }
        }

        function drawShooter() {
            const canvas = elements.shooterCanvas;
            const ctx = canvas.getContext('2d');
            const { player, enemies, bullets, enemyBullets, stars } = shooterState;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw Stars
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--text-secondary');
            for (const star of stars) {
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
                ctx.fill();
            }

            // Player
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--text-primary');
            ctx.beginPath();
            ctx.moveTo(player.x + player.width / 2, player.y);
            ctx.lineTo(player.x, player.y + player.height);
            ctx.lineTo(player.x + player.width, player.y + player.height);
            ctx.closePath();
            ctx.fill();

            // Bullets
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent-primary');
            for(const bullet of bullets) ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);

            // Enemies
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--danger-color');
            for(const enemy of enemies) {
                ctx.beginPath();
                ctx.moveTo(enemy.x, enemy.y);
                ctx.lineTo(enemy.x + enemy.width, enemy.y);
                ctx.lineTo(enemy.x + enemy.width / 2, enemy.y + enemy.height);
                ctx.closePath();
                ctx.fill();
            }

            // Enemy Bullets
            ctx.fillStyle = '#ffc600';
            for(const bullet of enemyBullets) ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);

            // UI
            ctx.font = "16px 'Share Tech Mono'";
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--text-primary');
            ctx.fillText("SCORE: " + shooterState.score, 8, 20);
            ctx.fillText("LIVES: " + shooterState.lives, canvas.width - 85, 20);
        }

        document.addEventListener('mousemove', (e) => {
            if (!breakoutState.active) return;
            const canvas = elements.minigameCanvas;
            const relativeX = e.clientX - canvas.getBoundingClientRect().left;
            if (relativeX > 0 && relativeX < canvas.width) {
                breakoutState.paddle.x = relativeX - breakoutState.paddle.width / 2;
            }
        });

        document.addEventListener('keydown', (e) => {
            if (!shooterState.active) return;
            if (e.key === 'ArrowRight' || e.key === 'd') shooterState.keys.right = true;
            if (e.key === 'ArrowLeft' || e.key === 'a') shooterState.keys.left = true;
            if (e.key === ' ') shooterState.keys.space = true;
        });
        document.addEventListener('keyup', (e) => {
            if (!shooterState.active) return;
            if (e.key === 'ArrowRight' || e.key === 'd') shooterState.keys.right = false;
            if (e.key === 'ArrowLeft' || e.key === 'a') shooterState.keys.left = false;
            if (e.key === ' ') shooterState.keys.space = false;
        });

        function gameTick() {
            let needsRender = false;
            // Crafting & Research
            gameState.crafting.queue.forEach(item => item.timeLeft--);
            const finishedJobs = gameState.crafting.queue.filter(item => item.timeLeft <= 0);
            if (finishedJobs.length > 0) {
                finishedJobs.forEach(job => {
                    if (job.type === 'research') { const recipeToUnlock = gameState.crafting.recipes.find(r => r.id === job.unlocks); if(recipeToUnlock) recipeToUnlock.isUnlocked = true; }
                    else if (job.type === 'fuel') { gameState.resources.fuel += 50; }
                    else if (job.type === 'drone') { gameState.resources.scoutDrones++; }
                    else { gameState.inventory.push({ ...job, id: gameState.nextItemId++ }); }
                });
                gameState.crafting.queue = gameState.crafting.queue.filter(item => item.timeLeft > 0);
                needsRender = true;
            }
            // Missions
            gameState.missions.active.forEach(mission => mission.timeLeft--);
            const finishedMissions = gameState.missions.active.filter(m => m.timeLeft <= 0);
            if (finishedMissions.length > 0) {
                finishedMissions.forEach(mission => {
                    if (mission.type === 'scout') { if (Math.random() > 0.5) { gameState.map.locations[mission.coord] = { name: 'New Anomaly', status: 'idle', mission: { id: `anomaly_${mission.coord}`, name: `Investigate ${mission.coord}`, difficulty: 50, cost: { fuel: 20 }, duration: 60, rewards: { materials: 300, credits: 1000 } } }; } }
                    else {
                        const merc = getOperativeById(mission.mercId);
                        if (Math.random() * 100 < getSuccessChance(getMercPower(merc), mission.difficulty)) { addResources(mission.rewards); merc.level++; }
                        else { if (merc.isCommander) { gameOver(); return; } }
                    }
                });
                gameState.missions.active = gameState.missions.active.filter(m => m.timeLeft > 0);
                needsRender = true;
            }
            if (needsRender) { renderAll(); } else { renderProductionQueue(); renderActiveMissions(); renderMap(); renderCrafting(); }
        }

        function init() {
            document.addEventListener('click', (e) => {
                const target = e.target;
                const mapTile = target.closest('.map-tile');

                if (mapTile) {
                    showLocationModal(mapTile.dataset.coord);
                } else if (target.matches('.view-profile-btn')) {
                    showMercProfileModal(parseInt(target.dataset.mercId));
                } else if (target.matches('.craft-btn')) {
                    craftItem(target.dataset.recipeId, target);
                } else if (target.matches('.equip-btn')) {
                    showEquipmentModal(parseInt(target.dataset.mercId), target.dataset.slot);
                } else if (target.matches('#recruit-merc-btn')) {
                    recruitMerc(target);
                } else if (target.matches('.equip-item-btn')) {
                    equipItem(parseInt(target.dataset.mercId), target.dataset.slot, parseInt(target.dataset.itemId));
                } else if (target.matches('.unequip-btn')) {
                    unequipItem(parseInt(target.dataset.mercId), target.dataset.slot);
                } else if (target.matches('#deploy-btn')) {
                    const mercSelect = document.getElementById('merc-select');
                    const location = gameState.map.locations[target.dataset.coord];
                    sendOnMission(parseInt(mercSelect.value), location.mission, target.dataset.coord, target);
                } else if (target.matches('#scout-btn')) {
                    scoutSector(target.dataset.coord, target);
                }
            });

            elements.navButtons.forEach(button => button.addEventListener('click', () => { if (button.disabled) return; elements.navButtons.forEach(btn => btn.classList.remove('active')); elements.gameSections.forEach(sec => sec.classList.remove('active')); button.classList.add('active'); document.getElementById(`${button.dataset.tab}-section`).classList.add('active'); }));
            elements.mercFilterButtons.addEventListener('click', (e) => { if (e.target.tagName === 'BUTTON') { elements.mercFilterButtons.querySelectorAll('button').forEach(btn => btn.classList.remove('active')); e.target.classList.add('active'); renderMercs(e.target.dataset.filter); } });
            
            elements.modal.addEventListener('change', (e) => {
                if (e.target.matches('#merc-select')) {
                    const mercSelect = e.target;
                    const deployBtn = document.getElementById('deploy-btn');
                    if (deployBtn) {
                        const location = gameState.map.locations[deployBtn.dataset.coord];
                        const selectedMerc = getOperativeById(parseInt(mercSelect.value));
                        if (selectedMerc && location) {
                            if (selectedMerc.isCommander) {
                                document.getElementById('success-chance-p').textContent = 'Success determined by skill.';
                            } else {
                                const chance = getSuccessChance(getMercPower(selectedMerc), location.mission.difficulty);
                                document.getElementById('success-chance-p').textContent = `Success Chance: ${chance}%`;
                            }
                        }
                    }
                }
            });

            elements.closeButton.onclick = closeModal;
            window.onclick = (e) => { if (e.target == elements.modal) closeModal(); };
            
            renderAll();
            gameLoopInterval = setInterval(gameTick, 1000);
        }

        init();
    });
    </script>
</body>
</html>
